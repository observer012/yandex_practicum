# Определение стоимости автомобилей

<h1>Содержание<span class='tocSkip'></span></h1>

* [1 Подготовка данных](#my_section_1) <a id='content_1'></a>
  * [1.1 Первичная загрузка](#my_section_2) <a id='content_2'></a>
  * [1.2 Изучение структуры файла](#my_section_3) <a id='content_3'></a>
  * [1.3 Первичная предобработка](#my_section_4) <a id='content_4'></a>
    * [1.3.1 Корректрировка имён столбцов](#my_section_5) <a id='content_5'></a>
    * [1.3.2 Корректировка типов данных](#my_section_6) <a id='content_6'></a>
    * [1.3.3 Оценка и удаление столбцов](#my_section_7) <a id='content_7'></a>
  * [1.4 Оценка значений](#my_section_8) <a id='content_8'></a>
    * [1.4.1 price](#my_section_9) <a id='content_9'></a>
    * [1.4.2 vehicle_type](#my_section_10) <a id='content_10'></a>
    * [1.4.3 registration_year](#my_section_11) <a id='content_11'></a>
    * [1.4.4 gearbox](#my_section_12) <a id='content_12'></a>
    * [1.4.5 power](#my_section_13) <a id='content_13'></a>
    * [1.4.6 model](#my_section_14) <a id='content_14'></a>
    * [1.4.7 kilometer](#my_section_15) <a id='content_15'></a>
    * [1.4.8 fuel_type](#my_section_16) <a id='content_16'></a>
    * [1.4.9 brand](#my_section_17) <a id='content_17'></a>
    * [1.4.10 repaired](#my_section_18) <a id='content_18'></a>
    * [1.4.11 Оценка дубликатов](#my_section_19) <a id='content_19'></a>
    * [1.4.12 Корреляция значений](#my_section_20) <a id='content_20'></a>
    * [1.4.13 Заключение](#my_section_21) <a id='content_21'></a>
  * [1.5 Корректировка значений](#my_section_22) <a id='content_22'></a>
    * [1.5.1 price](#my_section_23) <a id='content_23'></a>
    * [1.5.2 vehicle_type](#my_section_24) <a id='content_24'></a>
    * [1.5.3 registration_year](#my_section_25) <a id='content_25'></a>
    * [1.5.4 fuel_type](#my_section_26) <a id='content_26'></a>
    * [1.5.5 power](#my_section_27) <a id='content_27'></a>
    * [1.5.6 Заключение](#my_section_28) <a id='content_28'></a>
  * [1.6 Восстановление данных](#my_section_29) <a id='content_29'></a>
    * [1.6.1 power](#my_section_30) <a id='content_30'></a>
    * [1.6.2 gearbox](#my_section_31) <a id='content_31'></a>
    * [1.6.3 fuel_type](#my_section_32) <a id='content_32'></a>
    * [1.6.4 vehicle_type](#my_section_33) <a id='content_33'></a>
    * [1.6.5 model](#my_section_34) <a id='content_34'></a>
    * [1.6.6 repaired](#my_section_35) <a id='content_35'></a>
    * [1.6.7 Заключение](#my_section_36) <a id='content_36'></a>
  * [1.7 Дубликаты и удаление](#my_section_37) <a id='content_37'></a>
    * [1.7.1 Дубликаты](#my_section_38) <a id='content_38'></a>
    * [1.7.2 Пропуски](#my_section_39) <a id='content_39'></a>
    * [1.7.3 Заключение](#my_section_40) <a id='content_40'></a>
  * [1.8 Подготовка признаков](#my_section_41) <a id='content_41'></a>
  * [1.9 Заключение](#my_section_42) <a id='content_42'></a>
* [2 Обучение моделей](#my_section_43) <a id='content_43'></a>
  * [2.1 CatBoost](#my_section_44) <a id='content_44'></a>
  * [2.2 LightGBM](#my_section_45) <a id='content_45'></a>
  * [2.3 RandomForestRegressor](#my_section_46) <a id='content_46'></a>
* [3 Анализ моделей](#my_section_47) <a id='content_47'></a>
  * [3.1 CatBoost](#my_section_48) <a id='content_48'></a>
  * [3.2 LightGBM](#my_section_49) <a id='content_49'></a>
  * [3.3 RandomForestRegressor](#my_section_50) <a id='content_50'></a>
  * [3.4 Заключение](#my_section_51) <a id='content_51'></a>
* [4 Проверка качества](#my_section_52) <a id='content_52'></a>
* [5 Вывод](#my_section_53) <a id='content_53'></a>


<font style='font-size:20px; font-weight:bold'>Основные сведения</font><br/>

**Цель:** 
Построить модель, которая умеет определять рыночную стоимость автомобиля.


**Примечания заказчика:**
Используйте разные модели. Сравните характеристики.

- для оценки качества моделей применяйте метрику RMSE;
- значение метрики RMSE должно быть меньше 2500;
- используйте библиотеку LightGBM и её средствами постройте модели градиентного бустинга;
- оцените время выполнения ячейки кода Jupyter Notebook, где обучаются модели;


<font style='font-size:20px; font-weight:bold'>Этапы работы</font><br/>

1. Загрузка данных.
2. Изучение данных и подготовка.
3. Подготовление выборок для обучения моделей.
4. Обучение разных моделей.
5. Оценка времени обучения, времени предсказания и качества моделей.
6. Выбор лучшей модели.



<font style='font-size:20px; font-weight:bold'>Описание данных</font><br/>

Данные находятся в файле autos.csv


**Даны исторические данные автомобилей:**

- технические характеристики;
- комплектации;
- цены.


**Признаки**
- DateCrawled — дата скачивания анкеты из базы
- VehicleType — тип автомобильного кузова
- RegistrationYear — год регистрации автомобиля
- Gearbox — тип коробки передач
- Power — мощность (л. с.)
- Model — модель автомобиля
- Kilometer — пробег (км)
- RegistrationMonth — месяц регистрации автомобиля
- FuelType — тип топлива
- Brand — марка автомобиля
- Repaired — была машина в ремонте или нет
- DateCreated — дата создания анкеты
- NumberOfPictures — количество фотографий автомобиля
- PostalCode — почтовый индекс владельца анкеты (пользователя)
- LastSeen — дата последней активности пользователя

**Целевой признак**
- Price — цена (евро)





<a id='my_section_1'></a>
## [Подготовка данных](#content_1)

<a id='my_section_2'></a>
### [Первичная загрузка](#content_2)

Произведём импорт основных библиотек и модулей


```python
!pip install lightgbm
```

    Requirement already satisfied: lightgbm in d:\anaconda3\envs\practicum\lib\site-packages (3.3.5)
    Requirement already satisfied: wheel in d:\anaconda3\envs\practicum\lib\site-packages (from lightgbm) (0.38.4)
    Requirement already satisfied: scipy in d:\anaconda3\envs\practicum\lib\site-packages (from lightgbm) (1.8.0)
    Requirement already satisfied: scikit-learn!=0.22.0 in d:\anaconda3\envs\practicum\lib\site-packages (from lightgbm) (1.1.3)
    Requirement already satisfied: numpy in d:\anaconda3\envs\practicum\lib\site-packages (from lightgbm) (1.20.1)
    Requirement already satisfied: joblib>=1.0.0 in d:\anaconda3\envs\practicum\lib\site-packages (from scikit-learn!=0.22.0->lightgbm) (1.2.0)
    Requirement already satisfied: threadpoolctl>=2.0.0 in d:\anaconda3\envs\practicum\lib\site-packages (from scikit-learn!=0.22.0->lightgbm) (3.1.0)
    


```python
!pip install phik
```

    Requirement already satisfied: phik in d:\anaconda3\envs\practicum\lib\site-packages (0.12.3)
    Requirement already satisfied: matplotlib>=2.2.3 in d:\anaconda3\envs\practicum\lib\site-packages (from phik) (3.3.4)
    Requirement already satisfied: joblib>=0.14.1 in d:\anaconda3\envs\practicum\lib\site-packages (from phik) (1.2.0)
    Requirement already satisfied: scipy>=1.5.2 in d:\anaconda3\envs\practicum\lib\site-packages (from phik) (1.8.0)
    Requirement already satisfied: numpy>=1.18.0 in d:\anaconda3\envs\practicum\lib\site-packages (from phik) (1.20.1)
    Requirement already satisfied: pandas>=0.25.1 in d:\anaconda3\envs\practicum\lib\site-packages (from phik) (1.2.4)
    Requirement already satisfied: python-dateutil>=2.1 in d:\anaconda3\envs\practicum\lib\site-packages (from matplotlib>=2.2.3->phik) (2.8.2)
    Requirement already satisfied: pillow>=6.2.0 in d:\anaconda3\envs\practicum\lib\site-packages (from matplotlib>=2.2.3->phik) (8.4.0)
    Requirement already satisfied: cycler>=0.10 in d:\anaconda3\envs\practicum\lib\site-packages (from matplotlib>=2.2.3->phik) (0.11.0)
    Requirement already satisfied: pyparsing!=2.0.4,!=2.1.2,!=2.1.6,>=2.0.3 in d:\anaconda3\envs\practicum\lib\site-packages (from matplotlib>=2.2.3->phik) (3.0.9)
    Requirement already satisfied: kiwisolver>=1.0.1 in d:\anaconda3\envs\practicum\lib\site-packages (from matplotlib>=2.2.3->phik) (1.4.4)
    Requirement already satisfied: pytz>=2017.3 in d:\anaconda3\envs\practicum\lib\site-packages (from pandas>=0.25.1->phik) (2022.7)
    Requirement already satisfied: six>=1.5 in d:\anaconda3\envs\practicum\lib\site-packages (from python-dateutil>=2.1->matplotlib>=2.2.3->phik) (1.16.0)
    


```python
import time
import math
from IPython.display import display

import pandas as pd
import numpy as np
import phik
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
from sklearn.ensemble import RandomForestRegressor
from catboost import CatBoostRegressor
import lightgbm as lgb
from lightgbm import LGBMRegressor
```

Определим функцию для загрузки файла


```python
def download_file(name):
    """
    Функция проходит по возможным директориям 
    в попытке найти файл, используя конструкции
    try, except и итераторы. Возвращая прочтённый 
    файл или ошибку, если файл не найден.
    """
    def read(name):
        next_step = next(step)
        print(f'Пробую найти файл в {next_step}: {directory[next_step]}.')
        return pd.read_csv(directory[next_step] + name + '.csv')
    
    def error(err):
        print(f'Возникла ошибка: {err}\n')
        
    directory = {'windows':'', 'linux':'/datasets/', 'Internet':'https://..'}
    step = iter(directory)
    
    try:
        data = read(name)
    except FileNotFoundError as err:
        error(err)
        try:
            data = read(name)
        except FileNotFoundError as err:
            error(err)
            try:
                data = read(name)
            except FileNotFoundError:
                return error(err)
            
    print('Успех!')            
    return data           
```

Получим файл


```python
data = download_file('autos')
data_shape_zero_initially = data.shape[0]
```

    Пробую найти файл в windows: .
    Успех!
    

<a id='my_section_3'></a>
### [Изучение структуры файла](#content_3)

Чтение файла методом `head`


```python
data.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>DateCrawled</th>
      <th>Price</th>
      <th>VehicleType</th>
      <th>RegistrationYear</th>
      <th>Gearbox</th>
      <th>Power</th>
      <th>Model</th>
      <th>Kilometer</th>
      <th>RegistrationMonth</th>
      <th>FuelType</th>
      <th>Brand</th>
      <th>Repaired</th>
      <th>DateCreated</th>
      <th>NumberOfPictures</th>
      <th>PostalCode</th>
      <th>LastSeen</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2016-03-24 11:52:17</td>
      <td>480</td>
      <td>NaN</td>
      <td>1993</td>
      <td>manual</td>
      <td>0</td>
      <td>golf</td>
      <td>150000</td>
      <td>0</td>
      <td>petrol</td>
      <td>volkswagen</td>
      <td>NaN</td>
      <td>2016-03-24 00:00:00</td>
      <td>0</td>
      <td>70435</td>
      <td>2016-04-07 03:16:57</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2016-03-24 10:58:45</td>
      <td>18300</td>
      <td>coupe</td>
      <td>2011</td>
      <td>manual</td>
      <td>190</td>
      <td>NaN</td>
      <td>125000</td>
      <td>5</td>
      <td>gasoline</td>
      <td>audi</td>
      <td>yes</td>
      <td>2016-03-24 00:00:00</td>
      <td>0</td>
      <td>66954</td>
      <td>2016-04-07 01:46:50</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2016-03-14 12:52:21</td>
      <td>9800</td>
      <td>suv</td>
      <td>2004</td>
      <td>auto</td>
      <td>163</td>
      <td>grand</td>
      <td>125000</td>
      <td>8</td>
      <td>gasoline</td>
      <td>jeep</td>
      <td>NaN</td>
      <td>2016-03-14 00:00:00</td>
      <td>0</td>
      <td>90480</td>
      <td>2016-04-05 12:47:46</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2016-03-17 16:54:04</td>
      <td>1500</td>
      <td>small</td>
      <td>2001</td>
      <td>manual</td>
      <td>75</td>
      <td>golf</td>
      <td>150000</td>
      <td>6</td>
      <td>petrol</td>
      <td>volkswagen</td>
      <td>no</td>
      <td>2016-03-17 00:00:00</td>
      <td>0</td>
      <td>91074</td>
      <td>2016-03-17 17:40:17</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2016-03-31 17:25:20</td>
      <td>3600</td>
      <td>small</td>
      <td>2008</td>
      <td>manual</td>
      <td>69</td>
      <td>fabia</td>
      <td>90000</td>
      <td>7</td>
      <td>gasoline</td>
      <td>skoda</td>
      <td>no</td>
      <td>2016-03-31 00:00:00</td>
      <td>0</td>
      <td>60437</td>
      <td>2016-04-06 10:17:21</td>
    </tr>
  </tbody>
</table>
</div>



Оценка методом `describe`


```python
data.describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Price</th>
      <th>RegistrationYear</th>
      <th>Power</th>
      <th>Kilometer</th>
      <th>RegistrationMonth</th>
      <th>NumberOfPictures</th>
      <th>PostalCode</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>354369.000000</td>
      <td>354369.000000</td>
      <td>354369.000000</td>
      <td>354369.000000</td>
      <td>354369.000000</td>
      <td>354369.0</td>
      <td>354369.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>4416.656776</td>
      <td>2004.234448</td>
      <td>110.094337</td>
      <td>128211.172535</td>
      <td>5.714645</td>
      <td>0.0</td>
      <td>50508.689087</td>
    </tr>
    <tr>
      <th>std</th>
      <td>4514.158514</td>
      <td>90.227958</td>
      <td>189.850405</td>
      <td>37905.341530</td>
      <td>3.726421</td>
      <td>0.0</td>
      <td>25783.096248</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.000000</td>
      <td>1000.000000</td>
      <td>0.000000</td>
      <td>5000.000000</td>
      <td>0.000000</td>
      <td>0.0</td>
      <td>1067.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>1050.000000</td>
      <td>1999.000000</td>
      <td>69.000000</td>
      <td>125000.000000</td>
      <td>3.000000</td>
      <td>0.0</td>
      <td>30165.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>2700.000000</td>
      <td>2003.000000</td>
      <td>105.000000</td>
      <td>150000.000000</td>
      <td>6.000000</td>
      <td>0.0</td>
      <td>49413.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>6400.000000</td>
      <td>2008.000000</td>
      <td>143.000000</td>
      <td>150000.000000</td>
      <td>9.000000</td>
      <td>0.0</td>
      <td>71083.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>20000.000000</td>
      <td>9999.000000</td>
      <td>20000.000000</td>
      <td>150000.000000</td>
      <td>12.000000</td>
      <td>0.0</td>
      <td>99998.000000</td>
    </tr>
  </tbody>
</table>
</div>



*Некоторые имена столбцов состоят из нескольких слов, разделение идёт по символам верхнего регистра. Заметно наличие пропусков в данных. Некоторые признаки, предположительно не носят информативный характер и их стоит удалить:* **DateCrawled, DateCreated, NumberOfPictures, PostalCode, LastSeen , RegistrationMonth.** 

Заметно наличие выбросов, некоторые значения сразу говорят об ошибках в столбцах: **Price, RegistrationYear, Power, RegistrationMonth.**

Получение представления о данных методом `info`


```python
data.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 354369 entries, 0 to 354368
    Data columns (total 16 columns):
     #   Column             Non-Null Count   Dtype 
    ---  ------             --------------   ----- 
     0   DateCrawled        354369 non-null  object
     1   Price              354369 non-null  int64 
     2   VehicleType        316879 non-null  object
     3   RegistrationYear   354369 non-null  int64 
     4   Gearbox            334536 non-null  object
     5   Power              354369 non-null  int64 
     6   Model              334664 non-null  object
     7   Kilometer          354369 non-null  int64 
     8   RegistrationMonth  354369 non-null  int64 
     9   FuelType           321474 non-null  object
     10  Brand              354369 non-null  object
     11  Repaired           283215 non-null  object
     12  DateCreated        354369 non-null  object
     13  NumberOfPictures   354369 non-null  int64 
     14  PostalCode         354369 non-null  int64 
     15  LastSeen           354369 non-null  object
    dtypes: int64(7), object(9)
    memory usage: 43.3+ MB
    

1. Столбцы по типу данных, практически соответствуют себе. Возможно, стоит для столбцов с датой использовать datetime.
2. Обнаружены пропуски в признаках. 

Выделим столбцы, где обнаружены пропуски и сделаем предположение о характере пропусков.


```python
def how_percent(count, signs=2):
    return round(count/data.shape[0] *100,signs)

def isna_info(data):
    isna_info = data.isna().sum().sort_values(ascending=False)
    count = isna_info.loc[isna_info > 0]
    percent = how_percent(count)
    return pd.DataFrame({'количество':count, '%':percent})

isna_info(data)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>количество</th>
      <th>%</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Repaired</th>
      <td>71154</td>
      <td>20.08</td>
    </tr>
    <tr>
      <th>VehicleType</th>
      <td>37490</td>
      <td>10.58</td>
    </tr>
    <tr>
      <th>FuelType</th>
      <td>32895</td>
      <td>9.28</td>
    </tr>
    <tr>
      <th>Gearbox</th>
      <td>19833</td>
      <td>5.60</td>
    </tr>
    <tr>
      <th>Model</th>
      <td>19705</td>
      <td>5.56</td>
    </tr>
  </tbody>
</table>
</div>



- repaired — наличие пропусков вызвано, скорее всего, отсутствие машины в ремонте, вероятно, это новый автомобиль или автомбиль, который долгое время не использовался, также не стоит исключать вероятность пропуска в данных в результате ошибки; 
- vehicle_type, fuel_type, gearbox, model — вероятно, вызван ошибкой в данных или не возможностью заполняющего корректно указать значение.


<a id='my_section_4'></a>
### [Первичная предобработка](#content_4)

<a id='my_section_5'></a>
#### [Корректрировка имён столбцов](#content_5)

Обнаруженные недочёты в именах столбцов устраним. Определим функцию для переименования столбцов.


```python
def renaming_columns(data):
    """Функция меняет имена столбцов, 
    переводит в нижний регистр имена и 
    разделяет нижним подчёркиванием слова.
    """
    columns = []
    for el in data.columns:
        word = ''
        for i in range(len(el)):
            if el[i].islower():
                word += el[i]
            elif el[i].isupper() and i > 0:
                word += '_' + el[i].lower()
            else: 
                word += el[i].lower()
        columns.append(word)
    print(f'after update: {columns}')    
    return columns
```


```python
data.columns = renaming_columns(data)
```

    after update: ['date_crawled', 'price', 'vehicle_type', 'registration_year', 'gearbox', 'power', 'model', 'kilometer', 'registration_month', 'fuel_type', 'brand', 'repaired', 'date_created', 'number_of_pictures', 'postal_code', 'last_seen']
    

<a id='my_section_6'></a>
#### [Корректировка типов данных](#content_6)

Определим функцию для корректировки столбцов в которых имеется отношение к дате и времени.


```python
def type_date(data):
    dates = ['date_crawled', 'date_created', 'last_seen']
    for el in dates:
        data[el] = pd.to_datetime(data[el], format='%Y-%m-%d %H:%M:%S')
        
    return data
```


```python
data = type_date(data)
```

<a id='my_section_7'></a>
#### [Оценка и удаление столбцов](#content_7)

Решим вопрос про удаление выявленных ранее, потенциально не нужных столбцов: DateCrawled, DateCreated, NumberOfPictures, PostalCode, LastSeen, RegistrationMonth.


```python
data.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>date_crawled</th>
      <th>price</th>
      <th>vehicle_type</th>
      <th>registration_year</th>
      <th>gearbox</th>
      <th>power</th>
      <th>model</th>
      <th>kilometer</th>
      <th>registration_month</th>
      <th>fuel_type</th>
      <th>brand</th>
      <th>repaired</th>
      <th>date_created</th>
      <th>number_of_pictures</th>
      <th>postal_code</th>
      <th>last_seen</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2016-03-24 11:52:17</td>
      <td>480</td>
      <td>NaN</td>
      <td>1993</td>
      <td>manual</td>
      <td>0</td>
      <td>golf</td>
      <td>150000</td>
      <td>0</td>
      <td>petrol</td>
      <td>volkswagen</td>
      <td>NaN</td>
      <td>2016-03-24</td>
      <td>0</td>
      <td>70435</td>
      <td>2016-04-07 03:16:57</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2016-03-24 10:58:45</td>
      <td>18300</td>
      <td>coupe</td>
      <td>2011</td>
      <td>manual</td>
      <td>190</td>
      <td>NaN</td>
      <td>125000</td>
      <td>5</td>
      <td>gasoline</td>
      <td>audi</td>
      <td>yes</td>
      <td>2016-03-24</td>
      <td>0</td>
      <td>66954</td>
      <td>2016-04-07 01:46:50</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2016-03-14 12:52:21</td>
      <td>9800</td>
      <td>suv</td>
      <td>2004</td>
      <td>auto</td>
      <td>163</td>
      <td>grand</td>
      <td>125000</td>
      <td>8</td>
      <td>gasoline</td>
      <td>jeep</td>
      <td>NaN</td>
      <td>2016-03-14</td>
      <td>0</td>
      <td>90480</td>
      <td>2016-04-05 12:47:46</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2016-03-17 16:54:04</td>
      <td>1500</td>
      <td>small</td>
      <td>2001</td>
      <td>manual</td>
      <td>75</td>
      <td>golf</td>
      <td>150000</td>
      <td>6</td>
      <td>petrol</td>
      <td>volkswagen</td>
      <td>no</td>
      <td>2016-03-17</td>
      <td>0</td>
      <td>91074</td>
      <td>2016-03-17 17:40:17</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2016-03-31 17:25:20</td>
      <td>3600</td>
      <td>small</td>
      <td>2008</td>
      <td>manual</td>
      <td>69</td>
      <td>fabia</td>
      <td>90000</td>
      <td>7</td>
      <td>gasoline</td>
      <td>skoda</td>
      <td>no</td>
      <td>2016-03-31</td>
      <td>0</td>
      <td>60437</td>
      <td>2016-04-06 10:17:21</td>
    </tr>
  </tbody>
</table>
</div>



*Столбцы number_of_pictures и postal_code не несут значимой информации, их можно удалить. Эти данные скорее могут увеличить популярность объявления, чем его стоимость.*

Столбцы, которые несут информацию о времени размещения объявления, последнем входе пользователя и дате скачивания не несут прямой информации о стоимости. Характер этих столбцов может косвенно влиять на неё, например, если дата размещения объявления очень старая и она уже не соответствует курсу. Оценим целесообразность удаления этих столбцов.


```python
data.hist('registration_month', bins = 12, figsize=(8,4), xrot=90, xlabelsize=9);
```


    
![png](img/output_39_0.png)
    



```python
how_percent(data.loc[data['registration_month'] == 0].shape[0])
```




    10.54



*Месяц регистрации представленный 0, скорее всего обозначает пропуск в данных. Остальные данные представлены нормально, где наиболее популярным месяцем регистрации авто является декабрь. Данные в этом столбце не сказываются на стоимость.*

Оценим, когда анкеты были созданы


```python
data.hist('date_created', bins = 400, figsize=(11,4), xrot=90, xlabelsize=9);
```


    
![png](img/output_43_0.png)
    



```python
date_created_values = data['date_created'].sort_values().value_counts()
date_created_values.tail()
```




    2015-11-10    1
    2016-01-06    1
    2015-03-20    1
    2015-06-18    1
    2015-11-12    1
    Name: date_created, dtype: int64




```python
print(date_created_values.loc[date_created_values < 2].count())
```

    20
    

*Достаточно большое количество объявлений представлено в одном промежутке времени, однако, существует множество одиноких объявлений, созданных, вероятно в самом начале организации сервиса по продажам.*

Оценим, когда была последняя активность


```python
data.hist('last_seen', bins = 400, figsize=(11,4), xrot=90, xlabelsize=9);
```


    
![png](img/output_48_0.png)
    


Оценим, когда объявление было скачано


```python
data.hist('date_crawled', bins = 400, figsize=(11,4), xrot=90, xlabelsize=9);
```


    
![png](img/output_50_0.png)
    


Сопоставим три таблицы


```python
data.loc[:, ['date_crawled', 'date_created', 'last_seen']].sort_values(by='date_created').head(10)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>date_crawled</th>
      <th>date_created</th>
      <th>last_seen</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>61207</th>
      <td>2016-03-16 11:48:06</td>
      <td>2014-03-10</td>
      <td>2016-04-07 04:46:24</td>
    </tr>
    <tr>
      <th>4001</th>
      <td>2016-03-23 14:42:46</td>
      <td>2015-03-20</td>
      <td>2016-04-07 03:45:01</td>
    </tr>
    <tr>
      <th>342275</th>
      <td>2016-03-05 21:44:26</td>
      <td>2015-06-18</td>
      <td>2016-04-05 17:46:09</td>
    </tr>
    <tr>
      <th>86601</th>
      <td>2016-04-02 19:47:40</td>
      <td>2015-08-07</td>
      <td>2016-04-07 09:15:23</td>
    </tr>
    <tr>
      <th>175103</th>
      <td>2016-03-08 17:57:45</td>
      <td>2015-08-10</td>
      <td>2016-04-05 20:46:54</td>
    </tr>
    <tr>
      <th>221002</th>
      <td>2016-03-15 01:56:49</td>
      <td>2015-09-04</td>
      <td>2016-03-15 15:49:29</td>
    </tr>
    <tr>
      <th>75598</th>
      <td>2016-03-14 08:43:53</td>
      <td>2015-09-04</td>
      <td>2016-03-15 14:16:58</td>
    </tr>
    <tr>
      <th>340616</th>
      <td>2016-03-05 21:51:02</td>
      <td>2015-09-09</td>
      <td>2016-04-05 17:46:04</td>
    </tr>
    <tr>
      <th>9972</th>
      <td>2016-03-05 17:53:53</td>
      <td>2015-11-02</td>
      <td>2016-03-17 15:46:57</td>
    </tr>
    <tr>
      <th>161567</th>
      <td>2016-03-05 14:31:01</td>
      <td>2015-11-08</td>
      <td>2016-04-06 23:15:36</td>
    </tr>
  </tbody>
</table>
</div>



*Из гистограмм видно, что дата скачивания объявления не всегда соответствует его актуальности. Для корректного обучения модели, лучше всего выбрать промежуток, где за определённый момент времени цены на авто формируются наиболее большим набором данных. Из этого следует что будет не лишним ограничить выборку по дате создания анкеты.*

Определим промежуток времени


```python
data['date_created'].describe(datetime_is_numeric=True)
```




    count                           354369
    mean     2016-03-20 19:12:07.753274112
    min                2014-03-10 00:00:00
    25%                2016-03-13 00:00:00
    50%                2016-03-21 00:00:00
    75%                2016-03-29 00:00:00
    max                2016-04-07 00:00:00
    Name: date_created, dtype: object




```python
data_border = data['date_created'].value_counts()
data_border = data_border.reset_index().sort_values(by='index', ascending = False)
data_border.head(40)[30:]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>index</th>
      <th>date_created</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>13</th>
      <td>2016-03-08</td>
      <td>11854</td>
    </tr>
    <tr>
      <th>8</th>
      <td>2016-03-07</td>
      <td>12244</td>
    </tr>
    <tr>
      <th>29</th>
      <td>2016-03-06</td>
      <td>5505</td>
    </tr>
    <tr>
      <th>27</th>
      <td>2016-03-05</td>
      <td>8186</td>
    </tr>
    <tr>
      <th>33</th>
      <td>2016-03-04</td>
      <td>601</td>
    </tr>
    <tr>
      <th>35</th>
      <td>2016-03-03</td>
      <td>396</td>
    </tr>
    <tr>
      <th>39</th>
      <td>2016-03-02</td>
      <td>37</td>
    </tr>
    <tr>
      <th>36</th>
      <td>2016-03-01</td>
      <td>50</td>
    </tr>
    <tr>
      <th>38</th>
      <td>2016-02-29</td>
      <td>46</td>
    </tr>
    <tr>
      <th>37</th>
      <td>2016-02-28</td>
      <td>49</td>
    </tr>
  </tbody>
</table>
</div>




```python
how_percent(data_border.loc[data_border['index'] >= '2016-03-05', 'date_created'].sum()) 
```




    99.55



*Определим границу датой 2016-03-05, отсекая меньше 1% данных.*


```python
data = data.loc[data['date_created'] >= '2016-03-05']
```


```python
data.hist('date_created', bins = 35, figsize=(11,4), xrot=90, xlabelsize=9);
```


    
![png](img/output_60_0.png)
    


*Получив удовлетворительный результат, избавимся от столбцов, которые нам больше не нужны.*

Определим функцию, произведём удаление


```python
def del_poor_cool(data):
    poor_col = ['date_crawled', 'date_created', 'last_seen',
                'number_of_pictures', 'postal_code', 'registration_month']
    data = data.drop(poor_col, axis=1)
    return data
```


```python
data = del_poor_cool(data)
```

<a id='my_section_8'></a>
### [Оценка значений](#content_8)

Определим функцию для получения численного и процентного количества


```python
def values_with_percent(column):
    ans = data[column].value_counts(dropna=False)
    ans1 = how_percent(data[column].value_counts(dropna=False))
    return pd.concat({column:ans, '(%)':ans1}, axis=1)
```

Проведёи исследование данных, значений столбцов, их связей, дубликатов.


```python
data.describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
      <th>registration_year</th>
      <th>power</th>
      <th>kilometer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>352792.000000</td>
      <td>352792.000000</td>
      <td>352792.000000</td>
      <td>352792.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>4412.256451</td>
      <td>2004.238772</td>
      <td>110.071793</td>
      <td>128230.033561</td>
    </tr>
    <tr>
      <th>std</th>
      <td>4512.839543</td>
      <td>90.412328</td>
      <td>190.213601</td>
      <td>37895.028368</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.000000</td>
      <td>1000.000000</td>
      <td>0.000000</td>
      <td>5000.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>1050.000000</td>
      <td>1999.000000</td>
      <td>69.000000</td>
      <td>125000.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>2700.000000</td>
      <td>2003.000000</td>
      <td>105.000000</td>
      <td>150000.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>6399.000000</td>
      <td>2008.000000</td>
      <td>142.000000</td>
      <td>150000.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>20000.000000</td>
      <td>9999.000000</td>
      <td>20000.000000</td>
      <td>150000.000000</td>
    </tr>
  </tbody>
</table>
</div>




```python
data.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
      <th>vehicle_type</th>
      <th>registration_year</th>
      <th>gearbox</th>
      <th>power</th>
      <th>model</th>
      <th>kilometer</th>
      <th>fuel_type</th>
      <th>brand</th>
      <th>repaired</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>480</td>
      <td>NaN</td>
      <td>1993</td>
      <td>manual</td>
      <td>0</td>
      <td>golf</td>
      <td>150000</td>
      <td>petrol</td>
      <td>volkswagen</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>18300</td>
      <td>coupe</td>
      <td>2011</td>
      <td>manual</td>
      <td>190</td>
      <td>NaN</td>
      <td>125000</td>
      <td>gasoline</td>
      <td>audi</td>
      <td>yes</td>
    </tr>
    <tr>
      <th>2</th>
      <td>9800</td>
      <td>suv</td>
      <td>2004</td>
      <td>auto</td>
      <td>163</td>
      <td>grand</td>
      <td>125000</td>
      <td>gasoline</td>
      <td>jeep</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1500</td>
      <td>small</td>
      <td>2001</td>
      <td>manual</td>
      <td>75</td>
      <td>golf</td>
      <td>150000</td>
      <td>petrol</td>
      <td>volkswagen</td>
      <td>no</td>
    </tr>
    <tr>
      <th>4</th>
      <td>3600</td>
      <td>small</td>
      <td>2008</td>
      <td>manual</td>
      <td>69</td>
      <td>fabia</td>
      <td>90000</td>
      <td>gasoline</td>
      <td>skoda</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>



<a id='my_section_9'></a>
#### [price](#content_9)

Оценим значения столбца


```python
data.hist('price', bins = 200, figsize=(11,4))
```




    array([[<AxesSubplot:title={'center':'price'}>]], dtype=object)




    
![png](img/output_73_1.png)
    



```python
data['price'].describe()
```




    count    352792.000000
    mean       4412.256451
    std        4512.839543
    min           0.000000
    25%        1050.000000
    50%        2700.000000
    75%        6399.000000
    max       20000.000000
    Name: price, dtype: float64




```python
data.boxplot('price')
```




    <AxesSubplot:>




    
![png](img/output_75_1.png)
    



```python
data['price'].value_counts().reset_index().sort_values(by='index').head(5)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>index</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>10747</td>
    </tr>
    <tr>
      <th>75</th>
      <td>1</td>
      <td>1187</td>
    </tr>
    <tr>
      <th>969</th>
      <td>2</td>
      <td>12</td>
    </tr>
    <tr>
      <th>1111</th>
      <td>3</td>
      <td>8</td>
    </tr>
    <tr>
      <th>3039</th>
      <td>4</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>




```python
how_percent(data.loc[data['price'] == 0].shape[0]) 
```




    3.05



*Гистограмма показывает очень интересное распределение цен на авто. Подозрительно, что около 3% данных равны 0. Предположительно, это могут быть уже проданные авто. Либо, таким образом могут быть обозначены дубликаты. Значения, где цены равны от 1 евро и выше вызывают подозрения, согласно курсу ЦБ, 1 евро летом 2016 года составляло примерно 70 рублей. Изучив несколько сайтов были найдены автомобили за 16-20 тыс.рублей, т.е. где-то 228-250 евро. На иностарнных сайтах были найдены атво за 100$ это примерно 92 евро. А на иностранном сайте <a href="https://www.autoscout24.com/lst?atype=C&cy=D%2CA%2CB%2CE%2CF%2CI%2CL%2CNL&damaged_listing=exclude&desc=0&powertype=kw&search_id=1pa16z2wqyn&sort=price&ustate=N%2CU">www.autoscout24.com</a> были найдены авто с ценой 1 евро. Предположительно, заказчик ориентирован на торговлю за рубежом, исходя из того в какой валюте представлен транспорт(а значит, что стоимость в 1 евро уместа, согластно сайту). Однако, исходя из требований заказчика, приложение должно определять рыночную стоимость автомобиля. Соответственно, необходимо для модели машинного обучения подготовить данные ориентированные на клиента, который заинтересован продать своё авто как можно выгоднее для себя. Цены, которые представлены нижними значениями, предположительно, оценивают автомобили, почти не пригодные для эксплуатации. Также вероятно, что владельцы этих автомобилей нацелены просто на передачу авто за символическую сумму по иным причинам(особенности менталитета, дорогая аренда места хранения не используемого авто и т.д.). В итоге ограничимся наиболее приемлимыми ценами на авто, изуим нижнии границы цен.*


```python
data['price'].hist(bins=100, range=(200,1000))
```




    <AxesSubplot:>




    
![png](img/output_79_1.png)
    


Для более корректной фильтрации оценим, есть ли связь между 'kilometer' и 'price'. Есть предположение, что авто с малым пробегом стоят больше.


```python
data['kilometer'].sort_values().unique()
```




    array([  5000,  10000,  20000,  30000,  40000,  50000,  60000,  70000,
            80000,  90000, 100000, 125000, 150000], dtype=int64)




```python
data.loc[data['kilometer'] == 5000, 'price'].sort_values().hist(bins=100, range=(0,1000), figsize=(9, 4))
```




    <AxesSubplot:>




    
![png](img/output_82_1.png)
    


Изучим связть между 'repaired' и 'price'


```python
data.loc[(data['price'] >= 2) & (data['price'] <= 800), 'repaired'].value_counts(dropna=False)
```




    no     21255
    NaN    19481
    yes    14592
    Name: repaired, dtype: int64



*Связи между столбцами не заметны. Исходя из изложенных предположений и цен, ограничемся стоимостью автомобиля в 99 евро, что составляет примерно 9 057 рублей.*


```python
data.loc[data['price'] <= 99, 'price'].shape[0]/data.shape[0]*100
```




    3.766241864894895



Изучим дубликаты в данных без ключевого столбца `price`


```python
dup_price_filtr = data.duplicated(subset=[el for el in data.columns if el != 'price'], keep=False)
data.loc[(dup_price_filtr)].sort_values(by=[el for el in data.columns if el != 'price'], ascending=True).head(6)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
      <th>vehicle_type</th>
      <th>registration_year</th>
      <th>gearbox</th>
      <th>power</th>
      <th>model</th>
      <th>kilometer</th>
      <th>fuel_type</th>
      <th>brand</th>
      <th>repaired</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>168707</th>
      <td>3000</td>
      <td>bus</td>
      <td>1973</td>
      <td>NaN</td>
      <td>0</td>
      <td>other</td>
      <td>150000</td>
      <td>NaN</td>
      <td>volkswagen</td>
      <td>yes</td>
    </tr>
    <tr>
      <th>269797</th>
      <td>3000</td>
      <td>bus</td>
      <td>1973</td>
      <td>NaN</td>
      <td>0</td>
      <td>other</td>
      <td>150000</td>
      <td>NaN</td>
      <td>volkswagen</td>
      <td>yes</td>
    </tr>
    <tr>
      <th>51490</th>
      <td>13500</td>
      <td>bus</td>
      <td>1975</td>
      <td>manual</td>
      <td>0</td>
      <td>transporter</td>
      <td>150000</td>
      <td>petrol</td>
      <td>volkswagen</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>327005</th>
      <td>7800</td>
      <td>bus</td>
      <td>1975</td>
      <td>manual</td>
      <td>0</td>
      <td>transporter</td>
      <td>150000</td>
      <td>petrol</td>
      <td>volkswagen</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>37276</th>
      <td>17950</td>
      <td>bus</td>
      <td>1976</td>
      <td>manual</td>
      <td>50</td>
      <td>other</td>
      <td>100000</td>
      <td>petrol</td>
      <td>volkswagen</td>
      <td>no</td>
    </tr>
    <tr>
      <th>127574</th>
      <td>13900</td>
      <td>bus</td>
      <td>1976</td>
      <td>manual</td>
      <td>50</td>
      <td>other</td>
      <td>100000</td>
      <td>petrol</td>
      <td>volkswagen</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>




```python
data.loc[(dup_price_filtr)].sort_values(by=[el for el in data.columns if el != 'price'], ascending=False).head(6)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
      <th>vehicle_type</th>
      <th>registration_year</th>
      <th>gearbox</th>
      <th>power</th>
      <th>model</th>
      <th>kilometer</th>
      <th>fuel_type</th>
      <th>brand</th>
      <th>repaired</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>294605</th>
      <td>17800</td>
      <td>wagon</td>
      <td>2016</td>
      <td>manual</td>
      <td>99</td>
      <td>other</td>
      <td>5000</td>
      <td>gasoline</td>
      <td>peugeot</td>
      <td>no</td>
    </tr>
    <tr>
      <th>310248</th>
      <td>17800</td>
      <td>wagon</td>
      <td>2016</td>
      <td>manual</td>
      <td>99</td>
      <td>other</td>
      <td>5000</td>
      <td>gasoline</td>
      <td>peugeot</td>
      <td>no</td>
    </tr>
    <tr>
      <th>14806</th>
      <td>17500</td>
      <td>wagon</td>
      <td>2015</td>
      <td>manual</td>
      <td>150</td>
      <td>leon</td>
      <td>20000</td>
      <td>petrol</td>
      <td>seat</td>
      <td>no</td>
    </tr>
    <tr>
      <th>42206</th>
      <td>18900</td>
      <td>wagon</td>
      <td>2015</td>
      <td>manual</td>
      <td>150</td>
      <td>leon</td>
      <td>20000</td>
      <td>petrol</td>
      <td>seat</td>
      <td>no</td>
    </tr>
    <tr>
      <th>48936</th>
      <td>17000</td>
      <td>wagon</td>
      <td>2015</td>
      <td>manual</td>
      <td>125</td>
      <td>superb</td>
      <td>40000</td>
      <td>petrol</td>
      <td>skoda</td>
      <td>no</td>
    </tr>
    <tr>
      <th>297156</th>
      <td>17000</td>
      <td>wagon</td>
      <td>2015</td>
      <td>manual</td>
      <td>125</td>
      <td>superb</td>
      <td>40000</td>
      <td>petrol</td>
      <td>skoda</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>



*Заметен сильный разброс цен для авто зарегестрированных давно. У авто, зарегистрированных недавно, разброс цен гораздо меньше.*

**Вывод:**

Требуется провести фильтрацию данных, убрать значения, где присутствует 0. Это целевой признак, его парамтеры критически важны. Ограничить нижнюю границу в 99 евро, верхнюю границу трогать не будем.

<a id='my_section_10'></a>
#### [vehicle_type](#content_10)

Оценим столбец на предмет корректности заполненных значений, есть вероятность, что названия могут дублировать друг друга.


```python
data['vehicle_type'].sort_values().unique()
```




    array(['bus', 'convertible', 'coupe', 'other', 'sedan', 'small', 'suv',
           'wagon', nan], dtype=object)



Разберёмся, что эти типы значат:
1. bus — скорее всего относится к автобусам, компактвэнам, минивенам, хетчбэкам;
2. convertible — кабриоле́т; 
3. coupe — купе;
4. sedan — седан;
5. small — европейский малый класс;
6. suv — кроссовер(Sports Utility Vehicle);
7. wagon — универсал('сарай', 'вагон', 'авант', 'эстейт', 'комби').

Оценим распределение типов автомобильного кузова


```python
values_with_percent('vehicle_type')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>vehicle_type</th>
      <th>(%)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>sedan</th>
      <td>91033</td>
      <td>25.80</td>
    </tr>
    <tr>
      <th>small</th>
      <td>79495</td>
      <td>22.53</td>
    </tr>
    <tr>
      <th>wagon</th>
      <td>64876</td>
      <td>18.39</td>
    </tr>
    <tr>
      <th>NaN</th>
      <td>37352</td>
      <td>10.59</td>
    </tr>
    <tr>
      <th>bus</th>
      <td>28652</td>
      <td>8.12</td>
    </tr>
    <tr>
      <th>convertible</th>
      <td>20109</td>
      <td>5.70</td>
    </tr>
    <tr>
      <th>coupe</th>
      <td>16082</td>
      <td>4.56</td>
    </tr>
    <tr>
      <th>suv</th>
      <td>11916</td>
      <td>3.38</td>
    </tr>
    <tr>
      <th>other</th>
      <td>3277</td>
      <td>0.93</td>
    </tr>
  </tbody>
</table>
</div>



- other — тип кузова, который определить не удасться, имея неполный данные, которые завяленно отличаются друг от друга не выйдет в конечном итоге получить качественное предсказание по этому типу. Поэтому, смысла оставлять его особо нет.

**Вывод:** необходимо избавиться от типа кузова(vehicle_type) other — его присутствие не обеспечит надлежащего качества. 

<a id='my_section_11'></a>
#### [registration_year	](#content_11)


```python
data.columns
```




    Index(['price', 'vehicle_type', 'registration_year', 'gearbox', 'power',
           'model', 'kilometer', 'fuel_type', 'brand', 'repaired'],
          dtype='object')




```python
data['registration_year'].sort_values().unique()
```




    array([1000, 1001, 1039, 1111, 1200, 1234, 1253, 1255, 1300, 1400, 1500,
           1600, 1602, 1688, 1800, 1910, 1915, 1919, 1920, 1923, 1925, 1927,
           1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938,
           1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950,
           1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961,
           1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972,
           1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983,
           1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
           1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
           2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016,
           2017, 2018, 2019, 2066, 2200, 2222, 2290, 2500, 2800, 2900, 3000,
           3200, 3500, 3700, 3800, 4000, 4100, 4500, 4800, 5000, 5300, 5555,
           5600, 5900, 5911, 6000, 6500, 7000, 7100, 7500, 7800, 8000, 8200,
           8455, 8500, 8888, 9000, 9229, 9450, 9996, 9999], dtype=int64)



*Из полученного количества стоит обратить внимание только на наиболее достоверные.*


```python
data.loc[(data['registration_year'] >= 1940) & (data['registration_year'] <= 2030)]\
.hist('registration_year', bins = 80, figsize=(8,4))
```




    array([[<AxesSubplot:title={'center':'registration_year'}>]], dtype=object)




    
![png](img/output_104_1.png)
    


*С левого конца были отсечены значения вплоть до 1940 года, хотя и их стоит убрать. Вводить ограничения будем в соответствии с началом роста количества авто с годом регистрации от 1980-1990. Значения старше 2016 года не могут быть верными, так как они не соответствуют дате скачивания анкет. Есть вероятность, что возможна ошибка в данных регистрации авто или данных по анкетам.*

Оценим значения для ввода ограничений


```python
data.loc[(data['registration_year'] >= 1980) &
         (data['registration_year'] <= 1990), 'registration_year']\
        .value_counts()
```




    1990    2795
    1989    1313
    1988     938
    1985     753
    1987     666
    1980     587
    1986     533
    1983     425
    1984     396
    1982     312
    1981     259
    Name: registration_year, dtype: int64



Узнаем сколько значений останется за бортом


```python
how_percent(data.loc[(data['registration_year'] <= 1989), 'registration_year'].count())
```




    2.73



*Будем считать 1989 год точкой старта.*


```python
data.loc[(data['registration_year'] >= 2014) &
         (data['registration_year'] <= 2025), 'registration_year']\
        .value_counts()
```




    2017    10399
    2016     9573
    2018     3947
    2014     2521
    2015     1290
    2019       25
    Name: registration_year, dtype: int64




```python
how_percent(10399, 4)
```




    2.9476



*Странно, что около 10000 значений приходится на 2017 год. Это порядка 3%. Допустим, что всё-таки ошибка где-то присутствует.*

Узнаем сколько значений останется за бортом


```python
how_percent(data.loc[(data['registration_year'] >= 2018), 'registration_year'].count())
```




    1.16



**Вывод:** требуется ограничить значения по году регитсрации, обнаружены явные ошибки. Для ограничения использовать диапазон 1989 - 2017. Порядка 4% данных будет отсеяно.

<a id='my_section_12'></a>
#### [gearbox](#content_12)

Изучим уникальные значения


```python
data['gearbox'].unique()
```




    array(['manual', 'auto', nan], dtype=object)



Определим процентное соотношение


```python
values_with_percent('gearbox')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>gearbox</th>
      <th>(%)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>manual</th>
      <td>267071</td>
      <td>75.70</td>
    </tr>
    <tr>
      <th>auto</th>
      <td>65946</td>
      <td>18.69</td>
    </tr>
    <tr>
      <th>NaN</th>
      <td>19775</td>
      <td>5.61</td>
    </tr>
  </tbody>
</table>
</div>



*Оставим данные как есть, тут ничего не сделаешь*

**Вывод:** не выявлено явных ошибок.

<a id='my_section_13'></a>
#### [power](#content_13)

Оценим распределение значений


```python
data.hist('power', bins = 100, figsize = (8, 2))
```




    array([[<AxesSubplot:title={'center':'power'}>]], dtype=object)




    
![png](img/output_126_1.png)
    



```python
data['power'].describe()
```




    count    352792.000000
    mean        110.071793
    std         190.213601
    min           0.000000
    25%          69.000000
    50%         105.000000
    75%         142.000000
    max       20000.000000
    Name: power, dtype: float64




```python
how_percent(data.loc[(data['power'] == 0), 'power'].shape[0])
```




    11.36



*Из графика и таблицы видно, что есть значения, которые равны 0(11%), также из основной массы выделяются значения правого диапазона значений. Предположительно, значением 0 обозначены пропуски в данных. Их можно заполнить средним по каждому бренду, модели  и типу кузова, предварительно отфильтровав выбросы самых больших значений.*

Определим границы для фильтрации больших значений. Отбросим наиболее выбивающиеся значения, попробуем их выделить.


```python
np.percentile(data['power'].sort_values(), 90)
```




    179.0




```python
np.percentile(data['power'].sort_values(), 99.9)
```




    700.4180000000633




```python
data.loc[(data['power'] >= 0) & (data['power'] <= 700), 'power'].hist(bins=80, figsize=(11, 4))
```




    <AxesSubplot:>




    
![png](img/output_133_1.png)
    



```python
data.loc[data['power'] >= 700, 'power'].value_counts().reset_index().sort_values(by='index')[:8]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>index</th>
      <th>power</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>25</th>
      <td>700</td>
      <td>2</td>
    </tr>
    <tr>
      <th>160</th>
      <td>702</td>
      <td>1</td>
    </tr>
    <tr>
      <th>161</th>
      <td>703</td>
      <td>1</td>
    </tr>
    <tr>
      <th>172</th>
      <td>732</td>
      <td>1</td>
    </tr>
    <tr>
      <th>216</th>
      <td>743</td>
      <td>1</td>
    </tr>
    <tr>
      <th>7</th>
      <td>750</td>
      <td>4</td>
    </tr>
    <tr>
      <th>26</th>
      <td>751</td>
      <td>2</td>
    </tr>
    <tr>
      <th>237</th>
      <td>754</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>




```python
how_percent(data.loc[data['power'] >= 700, 'power'].count())
```




    0.1



*Остановимся на значении в 340 отбросив 0.1% данных. Чтобы избавиться от лишнего и не отсекать слишком много.*

Оценим нижнюю границу, исключая 0.


```python
data.loc[(data['power'] > 0) & (data['power'] <= 200), 'power'].hist(bins=50, figsize=(11, 4))
```




    <AxesSubplot:>




    
![png](img/output_138_1.png)
    



```python
data.loc[data['power'] <= 15, 'power'].value_counts().reset_index().sort_values(by='index').tail(5)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>index</th>
      <th>power</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4</th>
      <td>11</td>
      <td>28</td>
    </tr>
    <tr>
      <th>5</th>
      <td>12</td>
      <td>22</td>
    </tr>
    <tr>
      <th>13</th>
      <td>13</td>
      <td>8</td>
    </tr>
    <tr>
      <th>6</th>
      <td>14</td>
      <td>20</td>
    </tr>
    <tr>
      <th>7</th>
      <td>15</td>
      <td>20</td>
    </tr>
  </tbody>
</table>
</div>



*На  сайте <a href="https://auto.ru/krasnogorsk/cars/used/?power_to=13">auto.ru</a> покупки и продажи авто были найдены экземпляры с минимальной мощнсотью в 11 л.с., обозначим это нижней границей.* 

**Вывод:** требуется восстановлнение данных, где в признаке power указан 0, предварительно отфильтровав по нижнему значению в 11 л.с., а по верхнему значению в 340 л.с..

<a id='my_section_14'></a>
#### [model](#content_14)

Оценим значения. Изучим наименования на предмет не корректного заполнения.


```python
data['model'].sort_values().unique()
```




    array(['100', '145', '147', '156', '159', '1_reihe', '1er', '200',
           '2_reihe', '300c', '3_reihe', '3er', '4_reihe', '500', '5_reihe',
           '5er', '601', '6_reihe', '6er', '7er', '80', '850', '90', '900',
           '9000', '911', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a8',
           'a_klasse', 'accord', 'agila', 'alhambra', 'almera', 'altea',
           'amarok', 'antara', 'arosa', 'astra', 'auris', 'avensis', 'aveo',
           'aygo', 'b_klasse', 'b_max', 'beetle', 'berlingo', 'bora',
           'boxster', 'bravo', 'c1', 'c2', 'c3', 'c4', 'c5', 'c_klasse',
           'c_max', 'c_reihe', 'caddy', 'calibra', 'captiva', 'carisma',
           'carnival', 'cayenne', 'cc', 'ceed', 'charade', 'cherokee',
           'citigo', 'civic', 'cl', 'clio', 'clk', 'clubman', 'colt', 'combo',
           'cooper', 'cordoba', 'corolla', 'corsa', 'cr_reihe', 'croma',
           'crossfire', 'cuore', 'cx_reihe', 'defender', 'delta', 'discovery',
           'doblo', 'ducato', 'duster', 'e_klasse', 'elefantino', 'eos',
           'escort', 'espace', 'exeo', 'fabia', 'fiesta', 'focus', 'forester',
           'forfour', 'fortwo', 'fox', 'freelander', 'fusion', 'g_klasse',
           'galant', 'galaxy', 'getz', 'gl', 'glk', 'golf', 'grand', 'i3',
           'i_reihe', 'ibiza', 'impreza', 'insignia', 'jazz', 'jetta',
           'jimny', 'juke', 'justy', 'ka', 'kadett', 'kaefer', 'kalina',
           'kalos', 'kangoo', 'kappa', 'kuga', 'laguna', 'lancer', 'lanos',
           'legacy', 'leon', 'lodgy', 'logan', 'lupo', 'lybra', 'm_klasse',
           'm_reihe', 'materia', 'matiz', 'megane', 'meriva', 'micra', 'mii',
           'modus', 'mondeo', 'move', 'musa', 'mustang', 'mx_reihe', 'navara',
           'niva', 'note', 'nubira', 'octavia', 'omega', 'one', 'other',
           'outlander', 'pajero', 'panda', 'passat', 'phaeton', 'picanto',
           'polo', 'primera', 'ptcruiser', 'punto', 'q3', 'q5', 'q7',
           'qashqai', 'r19', 'range_rover', 'range_rover_evoque',
           'range_rover_sport', 'rangerover', 'rav', 'rio', 'roadster',
           'roomster', 'rx_reihe', 's60', 's_klasse', 's_max', 's_type',
           'samara', 'sandero', 'santa', 'scenic', 'scirocco', 'seicento',
           'serie_1', 'serie_2', 'serie_3', 'sharan', 'signum', 'sirion',
           'sl', 'slk', 'sorento', 'spark', 'spider', 'sportage', 'sprinter',
           'stilo', 'superb', 'swift', 'terios', 'tigra', 'tiguan', 'toledo',
           'touareg', 'touran', 'transit', 'transporter', 'tt', 'tucson',
           'twingo', 'up', 'v40', 'v50', 'v60', 'v70', 'v_klasse', 'vectra',
           'verso', 'viano', 'vito', 'vivaro', 'voyager', 'wrangler',
           'x_reihe', 'x_trail', 'x_type', 'xc_reihe', 'yaris', 'yeti',
           'ypsilon', 'z_reihe', 'zafira', nan], dtype=object)



Проверим, не повтрояют ли представители брендов названия моделей друг друга.



```python
unique_mod = []
non_unique_mod = []
for el in data['brand'].unique():
    model = data.loc[data['brand'] == el, 'model'].unique()
    for el in model:
        if el not in unique_mod:
            unique_mod.append(el)
        else:
            non_unique_mod.append(el)
            
print(set(non_unique_mod))
```

    {nan, '1_reihe', 'other', 'grand', 'freelander', '3_reihe', 'discovery', '5_reihe', 'matiz', 'defender'}
    

*Имеются повтроения, это надо учитывать при обработке значений.*

**Вывод:** по столбцу model не выявлено аномалий.

<a id='my_section_15'></a>
#### [kilometer](#content_15)


```python
data['kilometer'].unique()
```




    array([150000, 125000,  90000,  40000,  30000,  70000,   5000, 100000,
            60000,  20000,  80000,  50000,  10000], dtype=int64)



*Данные представлены очень небольшим набором значений, как если бы они перед этим проходили категоризацию. Предположительно этот столбец не дожен оказать сильного влияния на точность модели ввиде его ограниченного набора данных и специфики показателя.*


```python
data.hist('kilometer', bins=13, figsize=(11,3))
```




    array([[<AxesSubplot:title={'center':'kilometer'}>]], dtype=object)




    
![png](img/output_152_1.png)
    



```python
how_percent(data['kilometer'].value_counts())
```




    150000    67.25
    125000    10.28
    100000     4.19
    90000      3.26
    80000      2.83
    70000      2.42
    60000      2.10
    5000       1.81
    50000      1.75
    40000      1.38
    30000      1.25
    20000      1.12
    10000      0.34
    Name: kilometer, dtype: float64



*Данные не имеют пропусков, это приятно. Основной набор данных составляют подержанные авто, откатавшие большое расстояние(100-150тыс.). Малое количество данных составляют относительно новые автомобили, пройденное расстояние которых малозначительно(10-90тыс.).*

**Вывод:** *необходимость в корректировке столбца kilometer сомнительна. Данные на первый взгляд нормальные. Существует предположение о малой значимости этого столбца для машинного обучения ввиду специфики значений и их ограниченности.*

<a id='my_section_16'></a>
#### [fuel_type	](#content_16)

Оценим используемые типы топлива


```python
data['fuel_type'].unique()
```




    array(['petrol', 'gasoline', nan, 'lpg', 'other', 'hybrid', 'cng',
           'electric'], dtype=object)



Наименования:
- petrol — бензин(Великобритания);
- gasoline — бензин(США);
- lpg (Liquified Petroleum Gas) – сжиженный газ (пропан-бутан);
- hybrid — гибридное топливо(для машин, которые могут работать и от горючего и от электричества);
- cng (КПГ -компримированный (сжатый) природный газ);
- electric — это синтетический, альтернативный вид топлива, производимого с помощью электроэнергии.
- other — интересно, что же имеется ввиду.

*Обнаружено два одинаковых вида топлива: petrol и gasoline.*

Изучим распределение значений


```python
values_with_percent('fuel_type')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>fuel_type</th>
      <th>(%)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>petrol</th>
      <td>215402</td>
      <td>61.06</td>
    </tr>
    <tr>
      <th>gasoline</th>
      <td>98245</td>
      <td>27.85</td>
    </tr>
    <tr>
      <th>NaN</th>
      <td>32778</td>
      <td>9.29</td>
    </tr>
    <tr>
      <th>lpg</th>
      <td>5276</td>
      <td>1.50</td>
    </tr>
    <tr>
      <th>cng</th>
      <td>565</td>
      <td>0.16</td>
    </tr>
    <tr>
      <th>hybrid</th>
      <td>233</td>
      <td>0.07</td>
    </tr>
    <tr>
      <th>other</th>
      <td>204</td>
      <td>0.06</td>
    </tr>
    <tr>
      <th>electric</th>
      <td>89</td>
      <td>0.03</td>
    </tr>
  </tbody>
</table>
</div>



**Вывод:** *Тип other может быть пропуском, либо, это действительно, какой-то особый вид топлива. Интересно, что около 0.3% данных составляют редкие виды топлива(cng, hybrid, other, electric), предположительно, эти объекты обладают малым количеством значений, что негативно скажется на обучении модели. Возможно, после попытки восстановления, стоит еще раз оценить значения на предмет удаления. 9.28% — это пропущенные значения. Стоит скорректировать значения petrol и gasoline это одно и тоже.*

<a id='my_section_17'></a>
#### [brand](#content_17)

Изучим наименования брендов на предмет повторений и корректности наименований.


```python
data['brand'].sort_values().unique()
```




    array(['alfa_romeo', 'audi', 'bmw', 'chevrolet', 'chrysler', 'citroen',
           'dacia', 'daewoo', 'daihatsu', 'fiat', 'ford', 'honda', 'hyundai',
           'jaguar', 'jeep', 'kia', 'lada', 'lancia', 'land_rover', 'mazda',
           'mercedes_benz', 'mini', 'mitsubishi', 'nissan', 'opel', 'peugeot',
           'porsche', 'renault', 'rover', 'saab', 'seat', 'skoda', 'smart',
           'sonstige_autos', 'subaru', 'suzuki', 'toyota', 'trabant',
           'volkswagen', 'volvo'], dtype=object)



*Наименования значений представлены нормально.*

Изучим распределение авто по брендам


```python
values_with_percent('brand')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>brand</th>
      <th>(%)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>volkswagen</th>
      <td>76693</td>
      <td>21.74</td>
    </tr>
    <tr>
      <th>opel</th>
      <td>39753</td>
      <td>11.27</td>
    </tr>
    <tr>
      <th>bmw</th>
      <td>36739</td>
      <td>10.41</td>
    </tr>
    <tr>
      <th>mercedes_benz</th>
      <td>31905</td>
      <td>9.04</td>
    </tr>
    <tr>
      <th>audi</th>
      <td>29326</td>
      <td>8.31</td>
    </tr>
    <tr>
      <th>ford</th>
      <td>25074</td>
      <td>7.11</td>
    </tr>
    <tr>
      <th>renault</th>
      <td>17860</td>
      <td>5.06</td>
    </tr>
    <tr>
      <th>peugeot</th>
      <td>10951</td>
      <td>3.10</td>
    </tr>
    <tr>
      <th>fiat</th>
      <td>9597</td>
      <td>2.72</td>
    </tr>
    <tr>
      <th>seat</th>
      <td>6869</td>
      <td>1.95</td>
    </tr>
    <tr>
      <th>mazda</th>
      <td>5591</td>
      <td>1.58</td>
    </tr>
    <tr>
      <th>skoda</th>
      <td>5470</td>
      <td>1.55</td>
    </tr>
    <tr>
      <th>smart</th>
      <td>5225</td>
      <td>1.48</td>
    </tr>
    <tr>
      <th>citroen</th>
      <td>5124</td>
      <td>1.45</td>
    </tr>
    <tr>
      <th>nissan</th>
      <td>4919</td>
      <td>1.39</td>
    </tr>
    <tr>
      <th>toyota</th>
      <td>4590</td>
      <td>1.30</td>
    </tr>
    <tr>
      <th>hyundai</th>
      <td>3574</td>
      <td>1.01</td>
    </tr>
    <tr>
      <th>sonstige_autos</th>
      <td>3360</td>
      <td>0.95</td>
    </tr>
    <tr>
      <th>volvo</th>
      <td>3191</td>
      <td>0.90</td>
    </tr>
    <tr>
      <th>mini</th>
      <td>3181</td>
      <td>0.90</td>
    </tr>
    <tr>
      <th>mitsubishi</th>
      <td>3008</td>
      <td>0.85</td>
    </tr>
    <tr>
      <th>honda</th>
      <td>2800</td>
      <td>0.79</td>
    </tr>
    <tr>
      <th>kia</th>
      <td>2461</td>
      <td>0.70</td>
    </tr>
    <tr>
      <th>suzuki</th>
      <td>2314</td>
      <td>0.66</td>
    </tr>
    <tr>
      <th>alfa_romeo</th>
      <td>2303</td>
      <td>0.65</td>
    </tr>
    <tr>
      <th>chevrolet</th>
      <td>1741</td>
      <td>0.49</td>
    </tr>
    <tr>
      <th>chrysler</th>
      <td>1429</td>
      <td>0.41</td>
    </tr>
    <tr>
      <th>dacia</th>
      <td>898</td>
      <td>0.25</td>
    </tr>
    <tr>
      <th>daihatsu</th>
      <td>804</td>
      <td>0.23</td>
    </tr>
    <tr>
      <th>subaru</th>
      <td>755</td>
      <td>0.21</td>
    </tr>
    <tr>
      <th>porsche</th>
      <td>748</td>
      <td>0.21</td>
    </tr>
    <tr>
      <th>jeep</th>
      <td>673</td>
      <td>0.19</td>
    </tr>
    <tr>
      <th>trabant</th>
      <td>587</td>
      <td>0.17</td>
    </tr>
    <tr>
      <th>land_rover</th>
      <td>541</td>
      <td>0.15</td>
    </tr>
    <tr>
      <th>daewoo</th>
      <td>538</td>
      <td>0.15</td>
    </tr>
    <tr>
      <th>saab</th>
      <td>522</td>
      <td>0.15</td>
    </tr>
    <tr>
      <th>jaguar</th>
      <td>504</td>
      <td>0.14</td>
    </tr>
    <tr>
      <th>rover</th>
      <td>485</td>
      <td>0.14</td>
    </tr>
    <tr>
      <th>lancia</th>
      <td>467</td>
      <td>0.13</td>
    </tr>
    <tr>
      <th>lada</th>
      <td>222</td>
      <td>0.06</td>
    </tr>
  </tbody>
</table>
</div>



**Вывод:** *исходя из полученных значений можно сделать предположение о том, что готовая модель машинного обучения будет лучше предсказывть цену авто для брендов, которые представлены большим количеством значений. В целом значения представлены нормально, столбец в корректировке не нуждается.*

<a id='my_section_18'></a>
#### [repaired](#content_18)

Оценим столбец по уникальности и процентному соотношению


```python
values_with_percent('repaired')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>repaired</th>
      <th>(%)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>no</th>
      <td>245955</td>
      <td>69.72</td>
    </tr>
    <tr>
      <th>NaN</th>
      <td>70899</td>
      <td>20.10</td>
    </tr>
    <tr>
      <th>yes</th>
      <td>35938</td>
      <td>10.19</td>
    </tr>
  </tbody>
</table>
</div>



*Достаточно большое количество пропусков, предположительно не ставился пользователем ввиду отсутствия машины в ремонте. Этот столбец, после восстановления данных можно кодировать в 0 и 1.*

<a id='my_section_19'></a>
#### [Оценка дубликатов](#content_19)

Посмотрим на общее количество явных дубликатов.


```python
dup_price_filtr = data.duplicated()
data.loc[(dup_price_filtr)].sort_values(by=[el for el in data.columns], ascending=True).head(6)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
      <th>vehicle_type</th>
      <th>registration_year</th>
      <th>gearbox</th>
      <th>power</th>
      <th>model</th>
      <th>kilometer</th>
      <th>fuel_type</th>
      <th>brand</th>
      <th>repaired</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>283241</th>
      <td>0</td>
      <td>bus</td>
      <td>1994</td>
      <td>manual</td>
      <td>0</td>
      <td>transporter</td>
      <td>150000</td>
      <td>gasoline</td>
      <td>volkswagen</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>254668</th>
      <td>0</td>
      <td>bus</td>
      <td>1994</td>
      <td>manual</td>
      <td>68</td>
      <td>transporter</td>
      <td>150000</td>
      <td>gasoline</td>
      <td>volkswagen</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>74809</th>
      <td>0</td>
      <td>bus</td>
      <td>1995</td>
      <td>manual</td>
      <td>68</td>
      <td>transporter</td>
      <td>150000</td>
      <td>gasoline</td>
      <td>volkswagen</td>
      <td>no</td>
    </tr>
    <tr>
      <th>300163</th>
      <td>0</td>
      <td>bus</td>
      <td>1995</td>
      <td>manual</td>
      <td>68</td>
      <td>transporter</td>
      <td>150000</td>
      <td>gasoline</td>
      <td>volkswagen</td>
      <td>no</td>
    </tr>
    <tr>
      <th>259813</th>
      <td>0</td>
      <td>bus</td>
      <td>1995</td>
      <td>manual</td>
      <td>102</td>
      <td>transporter</td>
      <td>150000</td>
      <td>gasoline</td>
      <td>volkswagen</td>
      <td>no</td>
    </tr>
    <tr>
      <th>64344</th>
      <td>0</td>
      <td>bus</td>
      <td>1996</td>
      <td>auto</td>
      <td>110</td>
      <td>transporter</td>
      <td>150000</td>
      <td>petrol</td>
      <td>volkswagen</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>




```python
how_percent(data.duplicated().value_counts()[1])
```




    12.68



*Выявили почти 13% дубликатов во всей выборке.*

**Вывод:** *данные имеют 13% дубликатов, возможно, что после корректировки информации по столбцам количество дубликатов изменится. Стоит провести повторный анализ после мероприятий предобработки для принятия решения о корректировке.*

<a id='my_section_20'></a>
#### [Корреляция значений](#content_20)


```python
data.corr()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
      <th>registration_year</th>
      <th>power</th>
      <th>kilometer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>price</th>
      <td>1.000000</td>
      <td>0.026901</td>
      <td>0.158602</td>
      <td>-0.333130</td>
    </tr>
    <tr>
      <th>registration_year</th>
      <td>0.026901</td>
      <td>1.000000</td>
      <td>-0.000829</td>
      <td>-0.053605</td>
    </tr>
    <tr>
      <th>power</th>
      <td>0.158602</td>
      <td>-0.000829</td>
      <td>1.000000</td>
      <td>0.023871</td>
    </tr>
    <tr>
      <th>kilometer</th>
      <td>-0.333130</td>
      <td>-0.053605</td>
      <td>0.023871</td>
      <td>1.000000</td>
    </tr>
  </tbody>
</table>
</div>



*Обычный способ выявления коррелирующих значений не дал существенных результатов, воспользууемся библиотекой `phik`.*

Попробуем восстановить утраченные значения, чтобы понять какие признаки могут дополнять друг друга, попробуем найти корреляцию используя библиотеку `phik`.


```python
def phik_corr_matrix(data):
    interval_cols = ['price', 'power', 'kilometer']
    return data.phik_matrix(interval_cols=interval_cols)
```

Определим функцию для упрощения читаемости таблицы.


```python
def most_corr_val_phik(phik_corr, cor_cof=.4):
    """ Функция выводит имя столбца и список,
    который содержит имя признака с 
    которым коррелирует столбец и значение корреляции
    в соответствии с условием cor_cof
    
    """
    data_corr_phik = []
    # Блок выбирает значение, имя столбца, имя строки,
    # которые превышают указанный cor_cof и сохраняет в
    # data_corr_phik
    for el in phik_corr:
        for i in range(len(phik_corr[el])):
            if phik_corr[el][i] > cor_cof and phik_corr[el][i] != 1:
                data_corr_phik.extend([[el, phik_corr.index[i], round(phik_corr[el][i],3)]])

    # Этот блок фильтрует 
    # и сортирует значения
    some_dict = {}
    for el in data_corr_phik:
        for i in range(len(el)-1):
            # копирование листа
            el1 = el.copy()
            el1.remove(el[i])
            # внесение и создание ключа со значениями
            if el[i] not in some_dict.keys():
                some_dict[el[i]] = [el1]
            else:
                # Проверка на наличие однотипных значений
                count = 0
                for tr in some_dict[el[i]]:
                    if tr == el1:
                        count += 1
                if count == 0:
                    some_dict[el[i]] += [el1]
    count = 0
    for key, values in some_dict.items():
        count += 1
        print(f'{count}. {key:<15} {values}\n')
        
```


```python
phik_corr = phik_corr_matrix(data)
phik_corr
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
      <th>vehicle_type</th>
      <th>registration_year</th>
      <th>gearbox</th>
      <th>power</th>
      <th>model</th>
      <th>kilometer</th>
      <th>fuel_type</th>
      <th>brand</th>
      <th>repaired</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>price</th>
      <td>1.000000</td>
      <td>0.268142</td>
      <td>0.674610</td>
      <td>0.323692</td>
      <td>0.005771</td>
      <td>0.579035</td>
      <td>0.310958</td>
      <td>0.257507</td>
      <td>0.355571</td>
      <td>0.380445</td>
    </tr>
    <tr>
      <th>vehicle_type</th>
      <td>0.268142</td>
      <td>1.000000</td>
      <td>0.278259</td>
      <td>0.289090</td>
      <td>0.011784</td>
      <td>0.917284</td>
      <td>0.172040</td>
      <td>0.330037</td>
      <td>0.633306</td>
      <td>0.084591</td>
    </tr>
    <tr>
      <th>registration_year</th>
      <td>0.674610</td>
      <td>0.278259</td>
      <td>1.000000</td>
      <td>0.142468</td>
      <td>0.090179</td>
      <td>0.665489</td>
      <td>0.655332</td>
      <td>0.392530</td>
      <td>0.424113</td>
      <td>0.223959</td>
    </tr>
    <tr>
      <th>gearbox</th>
      <td>0.323692</td>
      <td>0.289090</td>
      <td>0.142468</td>
      <td>1.000000</td>
      <td>0.010526</td>
      <td>0.647004</td>
      <td>0.016211</td>
      <td>0.151410</td>
      <td>0.520612</td>
      <td>0.043643</td>
    </tr>
    <tr>
      <th>power</th>
      <td>0.005771</td>
      <td>0.011784</td>
      <td>0.090179</td>
      <td>0.010526</td>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.010865</td>
      <td>0.004528</td>
      <td>0.011686</td>
    </tr>
    <tr>
      <th>model</th>
      <td>0.579035</td>
      <td>0.917284</td>
      <td>0.665489</td>
      <td>0.647004</td>
      <td>0.000000</td>
      <td>1.000000</td>
      <td>0.443230</td>
      <td>0.555037</td>
      <td>0.998373</td>
      <td>0.159662</td>
    </tr>
    <tr>
      <th>kilometer</th>
      <td>0.310958</td>
      <td>0.172040</td>
      <td>0.655332</td>
      <td>0.016211</td>
      <td>0.000000</td>
      <td>0.443230</td>
      <td>1.000000</td>
      <td>0.148282</td>
      <td>0.274939</td>
      <td>0.113004</td>
    </tr>
    <tr>
      <th>fuel_type</th>
      <td>0.257507</td>
      <td>0.330037</td>
      <td>0.392530</td>
      <td>0.151410</td>
      <td>0.010865</td>
      <td>0.555037</td>
      <td>0.148282</td>
      <td>1.000000</td>
      <td>0.322657</td>
      <td>0.044536</td>
    </tr>
    <tr>
      <th>brand</th>
      <td>0.355571</td>
      <td>0.633306</td>
      <td>0.424113</td>
      <td>0.520612</td>
      <td>0.004528</td>
      <td>0.998373</td>
      <td>0.274939</td>
      <td>0.322657</td>
      <td>1.000000</td>
      <td>0.106007</td>
    </tr>
    <tr>
      <th>repaired</th>
      <td>0.380445</td>
      <td>0.084591</td>
      <td>0.223959</td>
      <td>0.043643</td>
      <td>0.011686</td>
      <td>0.159662</td>
      <td>0.113004</td>
      <td>0.044536</td>
      <td>0.106007</td>
      <td>1.000000</td>
    </tr>
  </tbody>
</table>
</div>




```python
most_corr_val_phik(phik_corr, .3)
```

    1. price           [['registration_year', 0.675], ['gearbox', 0.324], ['model', 0.579], ['kilometer', 0.311], ['brand', 0.356], ['repaired', 0.38]]
    
    2. registration_year [['price', 0.675], ['model', 0.665], ['kilometer', 0.655], ['fuel_type', 0.393], ['brand', 0.424]]
    
    3. gearbox         [['price', 0.324], ['model', 0.647], ['brand', 0.521]]
    
    4. model           [['price', 0.579], ['vehicle_type', 0.917], ['registration_year', 0.665], ['gearbox', 0.647], ['kilometer', 0.443], ['fuel_type', 0.555], ['brand', 0.998]]
    
    5. kilometer       [['price', 0.311], ['registration_year', 0.655], ['model', 0.443]]
    
    6. brand           [['price', 0.356], ['vehicle_type', 0.633], ['registration_year', 0.424], ['gearbox', 0.521], ['model', 0.998], ['fuel_type', 0.323]]
    
    7. repaired        [['price', 0.38]]
    
    8. vehicle_type    [['model', 0.917], ['fuel_type', 0.33], ['brand', 0.633]]
    
    9. fuel_type       [['vehicle_type', 0.33], ['registration_year', 0.393], ['model', 0.555], ['brand', 0.323]]
    
    

Для столбцов с пропусками выявлены наиболее коррелирующие стобцы:
- vehicle_type — model(0.917), brand(0.633);
- fuel_type — model(0.555);
- gearbox — model(0.647), brand(0.521);
- model — vehicle_type(0.917), brand(0.998)
- repaired — price(0.38).

*Возможно, что используя эти столбцы удастся восстановить пропущенные значения.*

<a id='my_section_21'></a>
#### [Заключение](#content_21)

По результату оценки каждого столбца были приняты заключения:

1. **price** — требуется провести фильтрацию данных, убрать значения, где присутствует 0(3%). Это целевой признак, его парамтеры критически важны. Нижнюю границу обозначить в 99 евро;
2. **vehicle_type** — необходимо избавиться от типа кузова(vehicle_type) other(0.93%) — его присутствие не обеспечит надлежащего качества;
3. **registration_year** — требуется ограничить значения по году регитсрации, обнаружены явные ошибки. Для ограничения использовать диапазон 1989 - 2017. Порядка 4% данных будет отсеяно;
4. **gearbox** — значения в порядке;
5. **power** — требуется восстановлнение данных, где в признаке power указан 0, предварительно отфильтровав по верхнему значению в 340 и нижнему в 11 л.с.;
6. **model** — по столбцу не выявлено аномалий, в наборе данных пристутсвуют одинаковые модели у разных брендов;
7. **kilometer** — необходимость в корректировке столбца kilometer сомнительна. Данные на первый взгляд нормальные. Существует предположение о малой значимости этого столбца для машинного обучения ввиду специфики значений и их ограниченности;
8. **fuel_type** — Тип other может быть пропуском, либо, это действительно, какой-то особый вид топлива. Интересно, что около 0.3% данных составляют редкие виды топлива(cng, hybrid, other, electric), предположительно, эти объекты обладают малым количеством значений, что негативно скажется на обучении модели. Возможно, после попытки восстановления, стоит еще раз оценить значения на предмет удаления. 9.28% — это пропущенные значения. Стоит скорректировать значения petrol и gasoline это одно и тоже;
9. **brand** — корректировка не нужна;
10. **repaired** — Достаточно большое количество пропусков, предположительно не ставился пользователем ввиду отсутствия машины в ремонте. Этот столбец, после восстановления данных можно кодировать в 0 и 1;
11. **оценка дубликатов** — данные имеют 13% дубликатов, возможно, что после корректировки информации по столбцам количество дубликатов изменится. Стоит провести повторный анализ после мероприятий предобработки для принятия решения о корректировке;
12. **корреляция значений** — выявлена коррелирующие столбцы с помощью которых, возможно, удастся восстановить недостающие значения: 
    - vehicle_type — model(0.917), brand(0.633);
    - fuel_type — model(0.555);
    - gearbox — model(0.647), brand(0.521);
    - model — vehicle_type(0.917), brand(0.998)
    - repaired — price(0.38).

<a id='my_section_22'></a>
### [Корректировка значений](#content_22)

Этот пункт подразумевает корректировку данных для конкретных стобцов, подготоавливая набор данных для восстановления. Столбцы, которые будут рассмотрены:
- price;
- vehicle_type;
- registration_year;
- fuel_type;
- power.

Определим функцию для оценки, сколько значений осталось после удаления


```python
def how_much_is_left(left=True):
    ans = round(data.shape[0]\
         /data_shape_zero_initially*100, 3)
    if left:
        print(f'Данных удалено: {100 - ans :.3f}%')
    else:    
        print(f'После удаления осталось данных:')
        print(f'- {ans}%.')
```

<a id='my_section_23'></a>
#### [price](#content_23)

Произведём ограничение значений по цене в 99 евро.


```python
data = data.loc[data['price'] >= 99]
```


```python
how_much_is_left()
```

    Данных удалено: 4.164%
    

<a id='my_section_24'></a>
#### [vehicle_type](#content_24)

Избавимся от типа кузова 'other'


```python
data = data.loc[data['vehicle_type'] != 'other']
```


```python
how_much_is_left()
```

    Данных удалено: 5.021%
    

<a id='my_section_25'></a>
#### [registration_year](#content_25)

Введём ограничения по году регистрации автомобиля(1989 - 2017).


```python
data = data.loc[(data['registration_year'] >= 1989) &
         (data['registration_year'] <= 2016)]
```


```python
how_much_is_left()
```

    Данных удалено: 10.900%
    

<a id='my_section_26'></a>
#### [fuel_type](#content_26)

Cкорректируем значения petrol и gasoline это одно и тоже.


```python
data.loc[data['fuel_type'] == 'gasoline', 'fuel_type'] = 'petrol'
```

Произведём фильтрацию по редким видам топлива: cng, hybrid, other, electric. 


```python
data = data.loc[(data['fuel_type'] != 'cng') &
                (data['fuel_type'] != 'hybrid') &
                (data['fuel_type'] != 'other') &
                (data['fuel_type'] != 'electric')]
```


```python
how_much_is_left()
```

    Данных удалено: 11.152%
    

<a id='my_section_27'></a>
#### [power](#content_27)


```python
data = data.loc[(data['power'] == 0) | (data['power'] >= 11) & (data['power'] <= 700)]
```


```python
how_much_is_left()
```

    Данных удалено: 11.271%
    

<a id='my_section_28'></a>
#### [Заключение](#content_28)


```python
how_much_is_left(False)
```

    После удаления осталось данных:
    - 88.729%.
    

*В результате корректировки, набор данных лишился 8% неявной информации.*

Произведена фильтрация значений, можно приступать к восстановлению данных.

<a id='my_section_29'></a>
### [Восстановление данных](#content_29)

Операцию будем проводить для столбцов в которых обнаружены пропуски:
- repaired;
- vehicle_type;
- fuel_type;
- gearbox;
- model;
- power.

Напомним корреляцию: 

- vehicle_type — model(0.917), brand(0.633);
- fuel_type — model(0.555);
- gearbox — model(0.647), brand(0.521);
- model — vehicle_type(0.917), brand(0.998)
- repaired — price(0.38).

Выовем функцию для демонстрации их количества и процентного соотношения


```python
isna_info(data)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>количество</th>
      <th>%</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>repaired</th>
      <td>55008</td>
      <td>17.49</td>
    </tr>
    <tr>
      <th>fuel_type</th>
      <td>21661</td>
      <td>6.89</td>
    </tr>
    <tr>
      <th>vehicle_type</th>
      <td>18140</td>
      <td>5.77</td>
    </tr>
    <tr>
      <th>gearbox</th>
      <td>13450</td>
      <td>4.28</td>
    </tr>
    <tr>
      <th>model</th>
      <td>13390</td>
      <td>4.26</td>
    </tr>
  </tbody>
</table>
</div>




```python
values_with_percent('power')[:1]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>power</th>
      <th>(%)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>29331</td>
      <td>9.33</td>
    </tr>
  </tbody>
</table>
</div>



*Начнём восстановление со столбца power*

<a id='my_section_30'></a>
#### [power](#content_30)

Определим функцию для восстановления данных. Функция будет считать среднюю мощность у конкретного бренда и модели определённого типа кузова, передавая среднее значение пропускам по этому фильтру.


```python
data.loc[data['power']==0, 'power'] = None
```


```python
data['power'] = data['power'].fillna(data.groupby(by=['brand', 'vehicle_type', 'model'],\
                                                  dropna=False)['power'].transform('median'))
```

Оценим результат


```python
data['power'].isna().value_counts()
```




    False    314270
    True        158
    Name: power, dtype: int64



*Как видно, часть значений притерпело изменения, будем надеятся корректно.*

<a id='my_section_31'></a>
#### [gearbox](#content_31)

Определим функцию для нахождения пропусков в `gearbox`


```python
def recovery_data(column):
    new_data = data.copy()
    new_data[column] = new_data[column].fillna(new_data.groupby(by=['brand', 'vehicle_type', 'model'], dropna=False)              
                           [column].agg(lambda x: x.value_counts(dropna=False).index[0])[0])
    
    return new_data[column]
```


```python
data['gearbox'] = recovery_data('gearbox')
```

Оценим результат обработки


```python
data['gearbox'].value_counts(dropna=False)
```




    manual    254148
    auto       60280
    Name: gearbox, dtype: int64



<a id='my_section_32'></a>
#### [fuel_type](#content_32)

Используем `recovery_data` для восстановления


```python
data['fuel_type'] = recovery_data('fuel_type')
```

Проверим результат


```python
data['fuel_type'].value_counts()
```




    petrol    309540
    lpg         4888
    Name: fuel_type, dtype: int64



<a id='my_section_33'></a>
#### [vehicle_type](#content_33)

Основываясь на значениях корреляции, восполним столбец самым частым значением для бренда и модели. Возьмём для оценки справделивости суждения произвольный бренд и модель. 


```python
data.loc[(data['brand']=='volkswagen') &
         (data['model']=='passat'), 'vehicle_type'].value_counts()
```




    wagon          6862
    sedan          2038
    coupe           176
    small             6
    bus               5
    suv               4
    convertible       1
    Name: vehicle_type, dtype: int64



*Если предположить, что тип кузова не указан, как раз потому, что это он наиболее распространен, тогда картинка складывается.*


```python
def recovery_other_data(column):
    new_data = data.copy()
    new_data[column] = new_data[column].fillna(new_data.groupby(by=['brand', 'model'], dropna=False)\
                [column].agg(lambda x: x.value_counts(dropna=False).index[0])[0])
    
    return new_data[column]
```


```python
data['vehicle_type'] = recovery_other_data('vehicle_type')
```


```python
isna_info(data)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>количество</th>
      <th>%</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>repaired</th>
      <td>55008</td>
      <td>17.49</td>
    </tr>
    <tr>
      <th>model</th>
      <td>13390</td>
      <td>4.26</td>
    </tr>
    <tr>
      <th>power</th>
      <td>158</td>
      <td>0.05</td>
    </tr>
  </tbody>
</table>
</div>



<a id='my_section_34'></a>
#### [model](#content_34)

Этот столбец коррелирует с `vehical_type` и `brand`. Определим похожий алгоритм, как и у других столбцов. Оценим возможность заполнения модели бренда выбранным видом кузова


```python
data.loc[(data['brand']=='volkswagen') &
         (data['vehicle_type']=='small'), 'model'].value_counts().head()
```




    polo      10664
    golf       5533
    lupo       2351
    fox         679
    passat      319
    Name: model, dtype: int64



*Предположительно, результат преобразования должен оправдать себя.*


```python
data['model'] = data['model'].fillna(data.groupby(by=['brand', 'vehicle_type'], dropna=False)\
                ['model'].agg(lambda x: x.value_counts(dropna=False).index[0])[0])
```


```python
isna_info(data)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>количество</th>
      <th>%</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>repaired</th>
      <td>55008</td>
      <td>17.49</td>
    </tr>
    <tr>
      <th>power</th>
      <td>158</td>
      <td>0.05</td>
    </tr>
  </tbody>
</table>
</div>



<a id='my_section_35'></a>
#### [repaired](#content_35)


Основное предположение заключается в том, что автомобиль бывший в ремонте дешевле своих собратьев(коррелирует с price 0.38). На этой основе будем создавать фильтр значений, где для пропуска, если цена автомобиля ниже медианы, то был в ремонте, если выше, то не был.


```python
# Список моделей, где repaired == yes
# с вычислением медианного и максимального значения цены
price_yes = data.loc[data['repaired'] == 'yes'].groupby('model', dropna=False)['price']
price_yes_median = price_yes.median()
price_yes_max = price_yes.max()
```


```python
# Список моделей, где repaired == no
# с вычислением медианного и максимального значения цены
price_no = data.loc[data['repaired'] == 'no'].groupby('model', dropna=False)['price']
price_no_median = price_no.median()
price_no_max = price_no.max()
```


```python
def recovery_repaired(data):
    if type(data['repaired']) != str:
        mod = data['model']
        # Проверка, есть ли модель в списках 
        if (mod in price_yes_median.index and
            mod in price_no_median.index):
            # Если есть, то вычисляется разница,
            # между значением медианы и текущей цены объекта 
            # для списков, где был ремонт и не было
            ans_yes = abs(price_yes_median[mod] - data['price'])
            ans_no = abs(price_no_median[mod] - data['price'])
            # В зависимости от того, что больше, определяется
            # принадлежность объекта к категории
            if ans_yes < ans_no:
                return 'yes'
            else:
                return 'no'
            
        # Условия ниже на случай, если модель объекта
        # находится только в одном из списков
        elif mod in price_yes_median.index:
            if data['price'] > price_yes_max[mod]:
                return 'no'
            else:
                return 'yes'
        # для неахождения категории используется
        # 1 квантиль
        elif mod in price_no_median.index:
            q1 = (price_no_median[mod]*2*.25)
            if data['price'] < q1:
                return 'yes'
            else:
                return 'no'
    else:
        return data['repaired']
```


```python
%%time
data['repaired'] = data.apply(recovery_repaired, axis=1)
```

    CPU times: total: 3.53 s
    Wall time: 3.54 s
    


```python
data['repaired'].value_counts()
```




    no     250077
    yes     64351
    Name: repaired, dtype: int64



*В целом значения распределились в основном в сторону критерия 'yes'(около 80% значений). Критерий 'no' получил около 20% значений.*

<a id='my_section_36'></a>
#### [Заключение](#content_36)

Оценим результат восстановления данных


```python
isna_info(data)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>количество</th>
      <th>%</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>power</th>
      <td>158</td>
      <td>0.05</td>
    </tr>
  </tbody>
</table>
</div>



*Удалось восстановить большую часть значений.*


<a id='my_section_37'></a>
### [Дубликаты и удаление](#content_37)

Оценим, какое количество значений от изначального набора осталось


```python
how_much_is_left(left=False)
```

    После удаления осталось данных:
    - 88.729%.
    

<a id='my_section_38'></a>
#### [Дубликаты](#content_38)

Проверим набор данных на предмет оставшихся дубликатов


```python
how_percent(data.duplicated().value_counts())
```




    False    83.09
    True     16.91
    dtype: float64



16% дубликатов — очень много, но от них придётся избавиться.


```python
data = data.drop_duplicates()
```

<a id='my_section_39'></a>
#### [Пропуски](#content_39)


```python
data = data.dropna()
```

<a id='my_section_40'></a>
#### [Заключение](#content_40)

Проведём оценку, какой процент данных остался от начального набора.


```python
how_much_is_left(left=False)
```

    После удаления осталось данных:
    - 73.699%.
    

*Потеря почти 24% данных — это очень много, но, видимо такой набор, процент дубликатов, оказался слишком высок.*

<a id='my_section_41'></a>
### [Подготовка признаков](#content_41)

Произведём разбиение набора данных на признаки


```python
features = data.drop(['price'], axis=1)
target = data['price']

features_train, features_valid, target_train, target_valid = train_test_split(
    features, target, test_size = .4, random_state=12345)

features_valid, features_test, target_valid, target_test = train_test_split(
    features_valid, target_valid, test_size = .5, random_state=12345)

dict_signs_norm = {'обучающая':features_train, 'валидационная':features_valid, 'тестовая':features_test}
print('Процентное соотношение выборок после разделения: ')
for key, val in dict_signs_norm.items():
    print(f'{key:<24} {val.shape[0]/data.shape[0]*100 :.4f}%')
```

    Процентное соотношение выборок после разделения: 
    обучающая                59.9999%
    валидационная            19.9998%
    тестовая                 20.0002%
    

**Для RFR модели**


```python
def for_rfr_model(data):
    def selection(select):
        features = select.drop(['price'], axis=1)
        target = select['price']
        return features, target
    
    new_data = pd.get_dummies(data, drop_first=True)
    train, valid, test = np.split(new_data.sample(frac=1, random_state=12345),\
                                  [int(.6*len(new_data)), int(.8*len(new_data))])
    
    dict_signs = {'обучающая':train, 'валидационная':valid, 'тестовая':test}
    print('Процентное соотношение выборок после разделения: ')
    for key, val in dict_signs.items():
        print(f'{key:<24} {val.shape[0]/data.shape[0]*100 :.4f}%')
        
    rfr_features_train, rfr_target_train = selection(train)
    rfr_features_valid, rfr_target_valid = selection(valid)
    rfr_features_test, rfr_target_test = selection(test)
    
    return rfr_features_train, rfr_target_train,\
            rfr_features_valid, rfr_target_valid,\
            rfr_features_test, rfr_target_test 

rfr_features_train, rfr_target_train,\
rfr_features_valid, rfr_target_valid,\
rfr_features_test, rfr_target_test = for_rfr_model(data) 
```

    Процентное соотношение выборок после разделения: 
    обучающая                59.9999%
    валидационная            19.9998%
    тестовая                 20.0002%
    

*Подготовили данные, произвели разбиение на разные выборки.*

<a id='my_section_42'></a>
### [Заключение](#content_42)

По итогу первой части были осуществлены меры по загрузке, изучению и подготовке данных:
1. Осуществлена загрузка и оценка значений, выявлены небольшие недочёты, такие как: 
    - пропуски в данных;
    - дубликаты;
    - неправильные типы данных у некоторых столбцов;
    - потенциально неинформативные столбцы;
    - некорректные имена столбцов;
    - ошибочные значения в значениях столбцов.
    
    
2. Проведена работа по устранению неточностей, корректировке и восстановлению значений.
3. Проведена работа по подготовке значений к дальнейшему исследованию. 

<a id='my_section_43'></a>
## [Обучение моделей](#content_43)

Обучим разные модели меняя гиперпараметры для получения большей точности.

<a id='my_section_44'></a>
### [CatBoost](#content_44)


```python
cat_features=['vehicle_type', 'gearbox', 'model', 'fuel_type', 'brand', 'repaired']
```


```python
%%time
best_RMSE = 5000
for depth in range(5,8):
    for ite in range(100,500,200):
        model_cb = CatBoostRegressor(iterations=ite, loss_function='RMSE',depth=depth, learning_rate=0.32)

        start_cb_fit = time.process_time()
        model_cb.fit(features_train, target_train, cat_features=cat_features, verbose=ite)
        finish_cb_fit = time.process_time() - start_cb_fit

        start_cb_predict = time.process_time()
        predictions_valid = model_cb.predict(features_valid)
        finish_cb_predict = time.process_time() - start_cb_predict

        result = mean_squared_error(target_valid, predictions_valid)**0.5
        if result <= best_RMSE:
            cb_best_RMSE_model = model_cb
            cb_best_RMSE = result
            cb_best_iter = ite
            cb_best_depth = depth
            cb_fit = finish_cb_fit
            cb_pred = finish_cb_predict
        
print(f'\nRMSE лучшей модели: {cb_best_RMSE}\n'
      f'Количество итераций: {cb_best_iter}\n'
      f'Лучшая глубина: {cb_best_depth}\n'
      f'Время обучения: {cb_fit}\n'
      f'Время предсказания: {cb_pred}\n')        
```

    0:	learn: 3746.6673338	total: 154ms	remaining: 15.2s
    99:	learn: 1631.6553930	total: 2.95s	remaining: 0us
    0:	learn: 3751.0962897	total: 40ms	remaining: 12s
    299:	learn: 1539.8029208	total: 13.7s	remaining: 0us
    0:	learn: 3697.0042951	total: 26.3ms	remaining: 2.6s
    99:	learn: 1596.9970624	total: 3.06s	remaining: 0us
    0:	learn: 3703.9816438	total: 46.4ms	remaining: 13.9s
    299:	learn: 1495.3510208	total: 16.5s	remaining: 0us
    0:	learn: 3650.3635751	total: 30.9ms	remaining: 3.05s
    99:	learn: 1563.0526265	total: 3.63s	remaining: 0us
    0:	learn: 3654.2003535	total: 76.6ms	remaining: 22.9s
    299:	learn: 1451.0049859	total: 21.5s	remaining: 0us
    
    RMSE лучшей модели: 1539.1777099046433
    Количество итераций: 300
    Лучшая глубина: 7
    Время обучения: 73.375
    Время предсказания: 0.171875
    
    CPU times: total: 3min 27s
    Wall time: 1min 3s
    

**Используем другие гиперпараметры**


```python
%%time
best_RMSE = 5000
for depth in range(13,15):
    for ite in range(100,500,200):
        model_cb2 = CatBoostRegressor(iterations=ite, loss_function='RMSE',depth=depth,
                                  learning_rate=0.32, bootstrap_type='Bernoulli')

        start_cb_fit = time.process_time()
        model_cb2.fit(features_train, target_train, cat_features=cat_features, verbose=ite)
        finish_cb_fit = time.process_time() - start_cb_fit

        start_cb_predict = time.process_time()
        predictions_valid = model_cb2.predict(features_valid)
        finish_cb_predict = time.process_time() - start_cb_predict

        result = mean_squared_error(target_valid, predictions_valid)**0.5
        if result <= best_RMSE:
            cb2_best_model = model_cb2
            cb2_best_RMSE = result
            cb2_best_iter = ite
            cb2_best_depth = depth
            cb2_fit = finish_cb_fit
            cb2_pred = finish_cb_predict
        
print(f'\nRMSE лучшей модели: {cb2_best_RMSE}\n'
      f'Количество итераций: {cb2_best_iter}\n'
      f'Лучшая глубина: {cb2_best_depth}\n'
      f'Время обучения: {cb2_fit}\n'
      f'Время преедсказания: {cb2_pred}\n')
```

    0:	learn: 3543.2348521	total: 134ms	remaining: 13.3s
    99:	learn: 1313.8996861	total: 13.1s	remaining: 0us
    0:	learn: 3539.3784294	total: 191ms	remaining: 57.1s
    299:	learn: 1115.6550321	total: 53.8s	remaining: 0us
    0:	learn: 3537.9856207	total: 211ms	remaining: 20.9s
    99:	learn: 1272.6240137	total: 21.4s	remaining: 0us
    0:	learn: 3525.0073755	total: 294ms	remaining: 1m 27s
    299:	learn: 1057.4571605	total: 1m 29s	remaining: 0us
    
    RMSE лучшей модели: 1551.5125899600837
    Количество итераций: 300
    Лучшая глубина: 14
    Время обучения: 313.421875
    Время преедсказания: 0.515625
    
    CPU times: total: 9min 55s
    Wall time: 3min
    

<a id='my_section_45'></a>
### [LightGBM](#content_45)


```python
non_numiric = ['vehicle_type', 'gearbox', 'model', 'fuel_type', 'brand', 'repaired']
```


```python
lgbm_features_train = features_train
lgbm_features_valid = features_valid

for n in non_numiric:
    lgbm_features_train[n] = lgbm_features_train[n].astype('category')
    lgbm_features_valid[n] = lgbm_features_valid[n].astype('category')
```


```python
train_dataset = lgb.Dataset(lgbm_features_train, target_train, feature_name=lgbm_features_train.columns.tolist(),
                            categorical_feature = non_numiric)
valid_dataset = lgb.Dataset(lgbm_features_valid, target_valid, feature_name=lgbm_features_valid.columns.tolist(),
                            categorical_feature = non_numiric)
```


```python
%%time
start = time.process_time()
booster = lgb.train({"objective": "regression"},
                    train_set=train_dataset, valid_sets=(valid_dataset,),
                    num_boost_round=500, verbose_eval=100)
time_result = time.process_time() - start
print(f'Время обучения: {time_result}')
```

    D:\Anaconda3\envs\practicum\lib\site-packages\lightgbm\basic.py:2065: UserWarning: Using categorical_feature in Dataset.
      _log_warning('Using categorical_feature in Dataset.')
    D:\Anaconda3\envs\practicum\lib\site-packages\lightgbm\engine.py:239: UserWarning: 'verbose_eval' argument is deprecated and will be removed in a future release of LightGBM. Pass 'log_evaluation()' callback via 'callbacks' argument instead.
      _log_warning("'verbose_eval' argument is deprecated and will be removed in a future release of LightGBM. "
    D:\Anaconda3\envs\practicum\lib\site-packages\lightgbm\basic.py:1780: UserWarning: Overriding the parameters from Reference Dataset.
      _log_warning('Overriding the parameters from Reference Dataset.')
    D:\Anaconda3\envs\practicum\lib\site-packages\lightgbm\basic.py:1513: UserWarning: categorical_column in param dict is overridden.
      _log_warning(f'{cat_alias} in param dict is overridden.')
    

    [LightGBM] [Warning] Auto-choosing row-wise multi-threading, the overhead of testing was 0.003169 seconds.
    You can set `force_row_wise=true` to remove the overhead.
    And if memory is not enough, you can set `force_col_wise=true`.
    [LightGBM] [Info] Total Bins 578
    [LightGBM] [Info] Number of data points in the train set: 156700, number of used features: 9
    [LightGBM] [Info] Start training from score 4796.283957
    [100]	valid_0's l2: 2.45015e+06
    [200]	valid_0's l2: 2.38544e+06
    [300]	valid_0's l2: 2.35494e+06
    [400]	valid_0's l2: 2.33771e+06
    [500]	valid_0's l2: 2.32834e+06
    Время обучения: 5.796875
    CPU times: total: 5.8 s
    Wall time: 1.17 s
    


```python
%%time
start = time.process_time()

valid_prediction = booster.predict(lgbm_features_valid)

time_result = time.process_time() - start
print(f'Время предсказания: {time_result}')

result = mean_squared_error(target_valid, valid_prediction)**0.5
print('\nRMSE', result)
```

    Время предсказания: 1.53125
    
    RMSE 1525.8892709081686
    CPU times: total: 1.53 s
    Wall time: 299 ms
    

**Используем другие гиперпараметры и обёртку**


```python
train_dataset = lgb.Dataset(lgbm_features_train, target_train, feature_name=lgbm_features_train.columns.tolist(),
                            categorical_feature = non_numiric)
valid_dataset = lgb.Dataset(lgbm_features_valid, target_valid, feature_name=lgbm_features_valid.columns.tolist(),
                            categorical_feature = non_numiric)
```


```python
best_lgbm_RMSE = 5000
for est in range(10, 50):
    model_lgbm = LGBMRegressor(n_estimators=est)

    start_lgbm_fit = time.process_time()
    model_lgbm.fit(lgbm_features_train, target_train)
    finish_lgbm_fit = time.process_time() - start_lgbm_fit

    start_lgbm_pred = time.process_time()
    yhat = model_lgbm.predict(lgbm_features_valid)
    finish_lgbm_pred = time.process_time() - start_lgbm_pred

    result = mean_squared_error(target_valid, yhat)**0.5
    if result <= best_lgbm_RMSE:
        best_lgbm_model = model_lgbm
        best_lgbm_RMSE = result
        best_lgbm_est = est
        lgbm_time_fit = finish_lgbm_fit
        lgbm_time_predict = finish_lgbm_pred      
    
print(f'RMSE лучшей LightGBM модели: {best_lgbm_RMSE}\n',
      f'n_estimators: {est}\n',
      f'Время обучения: {lgbm_time_fit}\n',
      f'Время предсказания: {lgbm_time_predict}\n')    
```

    RMSE лучшей LightGBM модели: 1605.548386341825
     n_estimators: 49
     Время обучения: 1.265625
     Время предсказания: 0.234375
    
    

<a id='my_section_46'></a>
### [RandomForestRegressor](#content_46)


```python
%%time
best_model = None
best_result = 10000
best_est = 0
best_depth = 0
for est in range(20, 30, 2):
    for depth in range (4, 7):
        model_rf = RandomForestRegressor(random_state=12345, n_estimators=est, max_depth=depth) 
        time_fit = time.process_time()
        model_rf.fit(rfr_features_train, rfr_target_train) 
        time_fit_result = time.process_time() - time_fit
        time_predictions = time.process_time()
        predictions_valid = model_rf.predict(rfr_features_valid) 
        time_predictions_result = time.process_time() - time_predictions
        result = mean_squared_error(rfr_target_valid, predictions_valid)**0.5 
        if result < best_result:
            best_model_rf = model_rf
            best_result = result
            best_est = est
            best_depth = depth
            best_time_fit = time_fit_result
            best_time_predictions = time_predictions_result

print("RMSE наилучшей модели на валидационной выборке:", best_result,
      "\nКоличество деревьев:", best_est, "\nМаксимальная глубина:", depth,
     "\nВремя обучения:", best_time_fit, "\nВремя предсказания:", best_time_predictions)
```

    RMSE наилучшей модели на валидационной выборке: 2178.785826920743 
    Количество деревьев: 20 
    Максимальная глубина: 6 
    Время обучения: 19.625 
    Время предсказания: 0.109375
    CPU times: total: 4min 44s
    Wall time: 4min 48s
    

<a id='my_section_47'></a>
## [Анализ моделей](#content_47)

<a id='my_section_48'></a>
### [CatBoost](#content_48)


```python
top_cb_model = cb_best_RMSE_model
```

- RMSE лучшей модели: 1539.1777099046433;
- Количество итераций: 300;
- Лучшая глубина: 7;
- Время обучения: 72.09375;
- Время предсказания: 0.15625.

<a id='my_section_49'></a>
### [LightGBM](#content_49)


```python
top_lgbm_model = best_lgbm_model
```

- num_boost_round: 500;
- Время обучения: 5.703125;
- Время предсказания: 1.65625;
- RMSE 1525.8892709081686.

<a id='my_section_50'></a>
### [RandomForestRegressor](#content_50)


```python
top_rfr_model = best_model_rf
```

- RMSE наилучшей модели на валидационной выборке: 2178.785826920743; 
- Количество деревьев: 20; 
- Максимальная глубина: 6;
- Время обучения: 18.046875; 
- Время предсказания: 0.09375.

<a id='my_section_51'></a>
### [Заключение](#content_51)

В соотношении качества и скорости выполнения лучше всего показала себя модель LightGBM, RMSE модели которой составило 1525.889.

<a id='my_section_52'></a>
## [Проверка качества](#content_52)


```python
test_dataset = lgb.Dataset(lgbm_features_valid, target_valid, feature_name=lgbm_features_valid.columns.tolist(),
                            categorical_feature = non_numiric)

lgbm_features_test = features_test

for n in non_numiric:
    lgbm_features_test[n] = lgbm_features_test[n].astype('category')
    
    
valid_dataset = lgb.Dataset(lgbm_features_test, target_test, feature_name=lgbm_features_test.columns.tolist(),
                            categorical_feature = non_numiric)    


start_test_time = time.process_time()
test_prediction = booster.predict(lgbm_features_test)
finish_test_time = time.process_time() - start_test_time
print(f'Время предсказания: {finish_test_time}')

result = mean_squared_error(target_test, test_prediction)**0.5
print('\nRMSE', result)

```

    Время предсказания: 1.625
    
    RMSE 1539.3502930966215
    

Модель показала высокую точность и скорость на валидационной выборке и подтвердила свои параметры на тестовой. Условия, заданные заказчиком выполнены.

<a id='my_section_53'></a>
## [Вывод](#content_53)

Проведена работа по задаче заказчика, была выполнена поставленная цель, лучшей моделью оказалась LightGBM. Достигнуты характеристики модели: 
1. тестовая выборка:
    - Время предсказания: 1.546875;
    - Оценка качества RMSE: 1539.3502930966215.
    
    
2. валидационная выборка:
    - Время обучения: 5.703125;
    - Время предсказания: 1.65625;
    - RMSE 11525.8892709081686.




В работе были выполнены этапы:
1. Осуществлена загрузка и оценка значений, выявлены небольшие недочёты, такие как: 
    - пропуски в данных;
    - дубликаты;
    - неправильные типы данных у некоторых столбцов;
    - потенциально неинформативные столбцы;
    - некорректные имена столбцов;
    - ошибочные значения в значениях столбцов.
    
    
2. проведена работа по устранению неточностей, корректировке и восстановлению значений;
3. проведена работа по подготовке значений к дальнейшему исследованию; 
4. осуществлено разделение значений на выборки;
5. проведено изучение разных моделей на подготовленных данных:
- CatBoost:
    - RMSE лучшей модели: 1539.1777099046433;
    - Количество итераций: 300;
    - Лучшая глубина: 7;
    - Время обучения: 72.09375;
    - Время предсказания: 0.15625.
- LightGBM:
    - num_boost_round: 500;
    - Время обучения: 5.703125;
    - Время предсказания: 1.65625;
    - RMSE 1525.8892709081686.
- RandomForestRegressor:
    - RMSE наилучшей модели на валидационной выборке: 2178.785826920743; 
    - Количество деревьев: 20; 
    - Максимальная глубина: 6;
    - Время обучения: 18.046875; 
    - Время предсказания: 0.09375.
    
Лучшей моделью по результату анализа стала LightGBM.    
В целом поставленную задачу можно считать выполненой. 
